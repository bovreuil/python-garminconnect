{% extends "base.html" %}

{% block title %}Dashboard - Garmin Heart Rate Analyzer{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1>Dashboard</h1>
            <div class="d-flex align-items-center gap-3">
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-primary" id="prevWeek">
                        <span>←</span>
                    </button>
                    <button type="button" class="btn btn-primary" id="todayBtn">Today</button>
                    <button type="button" class="btn btn-outline-primary" id="nextWeek">
                        <span>→</span>
                    </button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-secondary active" id="trimpBtn">TRIMP</button>
                    <button type="button" class="btn btn-outline-secondary" id="minutesBtn">Minutes</button>
                </div>
            </div>
        </div>
        
        <p class="text-muted mb-4">Welcome, {{ session.user_name }}! ({{ session.user_role }})</p>
    </div>
</div>

<!-- Two Week Chart Section -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Two Week Overview</h5>
                <small class="text-muted" id="dateRange"></small>
            </div>
            <div class="card-body">
                <div id="chartContainer" class="chart-container">
                    <canvas id="twoWeekChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Single Date View Section -->
<div class="row mt-4" id="singleDateSection" style="display: none;">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Single Date View</h5>
                <button type="button" class="btn btn-sm btn-outline-secondary" id="closeSingleDate">
                    <span>×</span>
                </button>
            </div>
            <div class="card-body">
                <!-- 24-Hour Heart Rate Chart -->
                <div class="row mb-4">
                    <div class="col-12">
                        <h6>24-Hour Heart Rate</h6>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="hrChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="row mb-4">
                    <div class="col-md-6">
                        <h6 id="selectedDateTitle">Date Details</h6>
                        <div id="dateDetails">
                            <p class="text-muted">Click on a column above to view details</p>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6>Heart Rate Zones</h6>
                        <div id="zoneBreakdown">
                            <p class="text-muted">Zone breakdown will appear here</p>
                        </div>
                    </div>
                </div>
                
                <!-- Activities Chart -->
                <div class="row mb-4">
                    <div class="col-12">
                        <h6>Activities</h6>
                        <div class="chart-container" id="activitiesChartContainer" style="height: 400px;">
                            <canvas id="activitiesChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Loading Indicator -->
<div id="loading" class="loading">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2">Loading data...</p>
</div>

<script>
// Register the DataLabels plugin
Chart.register(ChartDataLabels);

// Chart.js configuration
Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
Chart.defaults.font.size = 12;
Chart.defaults.color = '#2c3e50';

// Zone colors - temperature scale from cool to hot
const zoneColors = {
    '80-89': '#002040',    // Midnight
    '90-99': '#004080',    // Night sky blue
    '100-109': '#006d5b',  // Deep teal
    '110-119': '#28a745',  // Green
    '120-129': '#9acd32',  // Yellow-green
    '130-139': '#ffc107',  // Yellow
    '140-149': '#fd7e14',  // Orange
    '150-159': '#e74c3c',  // Red
    '160+': '#dc3545'      // Hot red
};

// Zone order for stacking (bottom to top)
const zoneOrder = [
    '80-89',
    '90-99',
    '100-109', 
    '110-119',
    '120-129',
    '130-139',
    '140-149',
    '150-159',
    '160+'
];

let twoWeekChart = null;
let hrChart = null;
let activitiesChart = null;
let currentStartDate = null;
let currentEndDate = null;
let currentMetric = 'trimp'; // 'trimp' or 'minutes'
let currentDataResults = []; // Store the current data results for click handling

// Initialize the dashboard
document.addEventListener('DOMContentLoaded', function() {
    // Set up event listeners
    document.getElementById('prevWeek').addEventListener('click', () => navigateWeek(-1));
    document.getElementById('nextWeek').addEventListener('click', () => navigateWeek(1));
    document.getElementById('todayBtn').addEventListener('click', goToToday);
    document.getElementById('trimpBtn').addEventListener('click', () => switchMetric('trimp'));
    document.getElementById('minutesBtn').addEventListener('click', () => switchMetric('minutes'));
    document.getElementById('closeSingleDate').addEventListener('click', closeSingleDateView);
    
    // Start with today's view
    goToToday();
});

// Calculate the two-week period that includes today
function calculateTwoWeekPeriod(today) {
    // Find the Monday of the week that contains today
    const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Convert to Monday-based
    
    const mondayOfThisWeek = new Date(today);
    mondayOfThisWeek.setDate(today.getDate() - daysFromMonday);
    
    // The second week is the week that contains today (Monday to Sunday)
    // The first week is the week before that (Monday to Sunday)
    const startDate = new Date(mondayOfThisWeek);
    startDate.setDate(mondayOfThisWeek.getDate() - 7);
    
    const endDate = new Date(mondayOfThisWeek);
    endDate.setDate(mondayOfThisWeek.getDate() + 6);
    
    return { startDate, endDate };
}

// Navigate by one week
function navigateWeek(direction) {
    if (!currentStartDate || !currentEndDate) return;
    
    // Close single date view when navigating
    closeSingleDateView();
    
    const newStartDate = new Date(currentStartDate);
    newStartDate.setDate(currentStartDate.getDate() + (direction * 7));
    
    const newEndDate = new Date(currentEndDate);
    newEndDate.setDate(currentEndDate.getDate() + (direction * 7));
    
    loadTwoWeekData(newStartDate, newEndDate);
}

// Go to today's two-week period
function goToToday() {
    // Close single date view when going to today
    closeSingleDateView();
    
    const today = new Date();
    const { startDate, endDate } = calculateTwoWeekPeriod(today);
    loadTwoWeekData(startDate, endDate);
}

// Switch between TRIMP and minutes
function switchMetric(metric) {
    currentMetric = metric;
    
    // Update button states
    document.getElementById('trimpBtn').classList.toggle('active', metric === 'trimp');
    document.getElementById('minutesBtn').classList.toggle('active', metric === 'minutes');
    
    // Reload data with new metric
    if (currentStartDate && currentEndDate) {
        loadTwoWeekData(currentStartDate, currentEndDate);
    }
    
    // Update activities chart if it exists
    if (activitiesChart) {
        // Get the current date from the single date view
        const singleDateSection = document.getElementById('singleDateSection');
        if (singleDateSection.style.display !== 'none') {
            // Find the date from the title
            const titleElement = document.getElementById('selectedDateTitle');
            if (titleElement) {
                const titleText = titleElement.textContent;
                // Extract date from title (e.g., "Monday, July 2, 2025")
                const dateMatch = titleText.match(/(\w+), (\w+ \d+, \d{4})/);
                if (dateMatch) {
                    const dateStr = dateMatch[2];
                    const date = new Date(dateStr);
                    loadActivitiesForDate(date);
                }
            }
        }
    }
}

// Load two weeks of data
function loadTwoWeekData(startDate, endDate) {
    currentStartDate = startDate;
    currentEndDate = endDate;
    
    showLoading();
    updateDateRange();
    
    // Generate array of 14 dates
    const dates = [];
    const currentDate = new Date(startDate);
    for (let i = 0; i < 14; i++) {
        dates.push(new Date(currentDate));
        currentDate.setDate(currentDate.getDate() + 1);
    }
    
    // Load data for all dates
    Promise.all(dates.map(date => loadDateData(date)))
        .then(results => {
            currentDataResults = results; // Store for click handling
            updateTwoWeekChart(dates, results);
            hideLoading();
        })
        .catch(error => {
            console.error('Error loading two week data:', error);
            hideLoading();
        });
}

// Load data for a single date
function loadDateData(date) {
    const dateStr = date.toISOString().split('T')[0];
    
    console.log(`Loading data for ${dateStr}`);
    
    return fetch(`/api/data/${dateStr}`)
        .then(response => {
            console.log(`Response for ${dateStr}:`, response.status, response.ok);
            if (!response.ok) {
                // Return null for dates with no data
                return null;
            }
            return response.json();
        })
        .then(data => {
            if (data) {
                console.log(`Data for ${dateStr}:`, data.total_trimp, data.presentation_buckets ? Object.keys(data.presentation_buckets) : 'no buckets');
            } else {
                console.log(`No data for ${dateStr}`);
            }
            return data;
        })
        .catch(error => {
            console.error(`Error loading data for ${dateStr}:`, error);
            return null;
        });
}

// Update the two-week chart
function updateTwoWeekChart(dates, dataResults) {
    const ctx = document.getElementById('twoWeekChart').getContext('2d');
    
    if (twoWeekChart) {
        twoWeekChart.destroy();
    }
    
    // Prepare data for stacked column chart
    const labels = dates.map(date => {
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const dayNum = date.getDate();
        return `${dayName} ${dayNum}`;
    });
    
    // Get all unique zones from the data
    const allZones = new Set();
    dataResults.forEach(data => {
        if (data && data.presentation_buckets) {
            Object.keys(data.presentation_buckets).forEach(zone => allZones.add(zone));
        }
    });
    
    // Sort zones according to our defined order (bottom to top)
    const sortedZones = zoneOrder.filter(zone => allZones.has(zone));
    
    // Create datasets for each zone in the correct order
    const datasets = sortedZones.map(zone => {
        const data = labels.map((_, index) => {
            const dayData = dataResults[index];
            if (!dayData || !dayData.presentation_buckets || !dayData.presentation_buckets[zone]) {
                return 0;
            }
            
            if (currentMetric === 'trimp') {
                return dayData.presentation_buckets[zone].trimp || 0;
            } else {
                return dayData.presentation_buckets[zone].minutes || 0;
            }
        });
        
        return {
            label: zone,
            data: data,
            backgroundColor: zoneColors[zone] || '#6c757d',
            borderWidth: 1,
            borderColor: '#ffffff'
        };
    });
    
    // Calculate the maximum value for Y-axis scaling
    let maxValue = 0;
    dataResults.forEach((dayData, index) => {
        if (dayData) {
            if (currentMetric === 'trimp') {
                maxValue = Math.max(maxValue, dayData.total_trimp || 0);
            } else {
                // Calculate total minutes for this day
                let totalMinutes = 0;
                if (dayData.presentation_buckets) {
                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                        totalMinutes += bucket.minutes || 0;
                    });
                }
                maxValue = Math.max(maxValue, totalMinutes);
            }
        }
    });
    
    // Calculate a proper max that aligns with Chart.js tick intervals
    let yAxisMax;
    if (maxValue === 0) {
        yAxisMax = 10; // Default for no data
    } else {
        // Determine step size based on the range
        let step;
        if (maxValue <= 50) step = 10;
        else if (maxValue <= 100) step = 20;
        else if (maxValue <= 200) step = 20;
        else if (maxValue <= 500) step = 50;
        else step = 100;
        
        // Add one extra step for label space
        yAxisMax = Math.ceil(maxValue / step) * step + step;
    }
    
    twoWeekChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: function(event, elements) {
                if (elements.length > 0) {
                    const dataIndex = elements[0].index;
                    const date = dates[dataIndex];
                    showSingleDateView(date, dataResults[dataIndex]);
                }
            },
            onHover: function(event, elements) {
                event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP Score' : 'Minutes'
                    },
                    beginAtZero: true,
                    max: yAxisMax
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true
                    }
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(context) {
                            const dataIndex = context[0].dataIndex;
                            const dayData = dataResults[dataIndex];
                            if (dayData && dayData.total_trimp !== undefined) {
                                return `Total: ${dayData.total_trimp.toFixed(1)} TRIMP`;
                            }
                            return '';
                        }
                    }
                }
            },
            plugins: {
                datalabels: {
                    display: function(context) {
                        // Only show labels for the top dataset (last in the stack)
                        return context.datasetIndex === datasets.length - 1;
                    },
                    anchor: 'end',
                    align: 'top',
                    formatter: function(value, context) {
                        // Calculate total for this column
                        const dataIndex = context.dataIndex;
                        const dayData = dataResults[dataIndex];
                        if (dayData) {
                            if (currentMetric === 'trimp') {
                                return dayData.total_trimp ? dayData.total_trimp.toFixed(1) : '0';
                            } else {
                                // Calculate total minutes
                                let totalMinutes = 0;
                                if (dayData.presentation_buckets) {
                                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                                        totalMinutes += bucket.minutes || 0;
                                    });
                                }
                                return totalMinutes > 0 ? totalMinutes.toFixed(0) : '0';
                            }
                        }
                        return '0';
                    },
                    color: '#2c3e50',
                    font: {
                        weight: 'bold',
                        size: 11
                    },
                    offset: 4
                }
            }
        }
    });
}

// Update the date range display
function updateDateRange() {
    if (!currentStartDate || !currentEndDate) return;
    
    const startStr = currentStartDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
    });
    const endStr = currentEndDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
    });
    
    document.getElementById('dateRange').textContent = `${startStr} - ${endStr}`;
}

// Show/hide loading
function showLoading() {
    document.getElementById('loading').style.display = 'block';
}

function hideLoading() {
    document.getElementById('loading').style.display = 'none';
}

// Show single date view
function showSingleDateView(date, dayData) {
    const dateStr = date.toLocaleDateString('en-US', { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    });
    
    document.getElementById('selectedDateTitle').textContent = dateStr;
    
    if (!dayData) {
        document.getElementById('dateDetails').innerHTML = '<p class="text-muted">No data available for this date</p>';
        document.getElementById('zoneBreakdown').innerHTML = '<p class="text-muted">No zone data available</p>';
        // Clear heart rate chart
        if (hrChart) {
            hrChart.destroy();
            hrChart = null;
        }
    } else {
        // Create 24-hour heart rate chart
        createHeartRateChart(date, dayData);
        
        // Display date details
        let detailsHtml = '<div class="row">';
        
        if (dayData.total_trimp !== undefined) {
            detailsHtml += `
                <div class="col-6">
                    <div class="text-center p-3 bg-light rounded">
                        <h4 class="text-primary mb-1">${dayData.total_trimp.toFixed(1)}</h4>
                        <small class="text-muted">Total TRIMP</small>
                    </div>
                </div>
            `;
        }
        
        if (dayData.presentation_buckets) {
            let totalMinutes = 0;
            Object.values(dayData.presentation_buckets).forEach(bucket => {
                totalMinutes += bucket.minutes || 0;
            });
            
            detailsHtml += `
                <div class="col-6">
                    <div class="text-center p-3 bg-light rounded">
                        <h4 class="text-success mb-1">${totalMinutes.toFixed(0)}</h4>
                        <small class="text-muted">Total Minutes</small>
                    </div>
                </div>
            `;
        }
        
        detailsHtml += '</div>';
        document.getElementById('dateDetails').innerHTML = detailsHtml;
        
        // Display zone breakdown
        if (dayData.presentation_buckets) {
            let zoneHtml = '<div class="table-responsive"><table class="table table-sm">';
            zoneHtml += '<thead><tr><th>Zone</th><th>Minutes</th><th>TRIMP</th><th>%</th></tr></thead><tbody>';
            
            const sortedZones = zoneOrder.filter(zone => dayData.presentation_buckets[zone]).reverse();
            let totalMinutes = 0;
            let totalTrimp = 0;
            
            // Calculate totals first
            sortedZones.forEach(zone => {
                const bucket = dayData.presentation_buckets[zone];
                totalMinutes += bucket.minutes || 0;
                totalTrimp += bucket.trimp || 0;
            });
            
            // Display each zone
            sortedZones.forEach(zone => {
                const bucket = dayData.presentation_buckets[zone];
                const minutes = bucket.minutes || 0;
                const trimp = bucket.trimp || 0;
                const percentage = totalMinutes > 0 ? ((minutes / totalMinutes) * 100).toFixed(1) : '0.0';
                
                zoneHtml += `
                    <tr>
                        <td>
                            <span class="badge" style="background-color: ${zoneColors[zone]}; color: white;">${zone}</span>
                        </td>
                        <td>${minutes.toFixed(0)}</td>
                        <td>${trimp.toFixed(1)}</td>
                        <td>${percentage}%</td>
                    </tr>
                `;
            });
            
            zoneHtml += '</tbody></table></div>';
            document.getElementById('zoneBreakdown').innerHTML = zoneHtml;
        } else {
            document.getElementById('zoneBreakdown').innerHTML = '<p class="text-muted">No zone data available</p>';
        }
    }
    
    // Show the section
    document.getElementById('singleDateSection').style.display = 'block';
    
    // Load and display activities for this date
    loadActivitiesForDate(date);
    
    // Scroll to the section
    document.getElementById('singleDateSection').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start' 
    });
}

// Close single date view
function closeSingleDateView() {
    document.getElementById('singleDateSection').style.display = 'none';
    
    // Destroy activities chart if it exists
    if (activitiesChart) {
        activitiesChart.destroy();
        activitiesChart = null;
    }
}

// Load activities for a specific date
function loadActivitiesForDate(date) {
    const dateStr = date.toISOString().split('T')[0];
    
    fetch(`/api/activities/${dateStr}`)
        .then(response => {
            if (!response.ok) {
                console.log(`No activities found for ${dateStr}`);
                return [];
            }
            return response.json();
        })
        .then(activities => {
            console.log(`Activities for ${dateStr}:`, activities);
            createActivitiesChart(activities);
        })
        .catch(error => {
            console.error(`Error loading activities for ${dateStr}:`, error);
            createActivitiesChart([]);
        });
}

// Create horizontal bar chart for activities
function createActivitiesChart(activities) {
    const ctx = document.getElementById('activitiesChart').getContext('2d');
    const chartContainer = document.getElementById('activitiesChartContainer');
    
    // Destroy existing chart if it exists
    if (activitiesChart) {
        activitiesChart.destroy();
    }
    
    if (!activities || activities.length === 0) {
        // No activities - show empty chart with message
        chartContainer.style.height = '100px'; // Small height for empty state
        activitiesChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                scales: {
                    x: {
                        display: false
                    },
                    y: {
                        display: false
                    }
                }
            }
        });
        
        // Add a message overlay
        chartContainer.innerHTML = '<div class="d-flex align-items-center justify-content-center h-100"><p class="text-muted">No activities for this date</p></div>';
        return;
    }
    
    // Calculate dynamic height based on number of activities
    // Each bar should be about 50px thick, plus some padding for labels and spacing
    const barHeight = 80; // Increased from 50 to give more space per bar
    const padding = 40; // Increased padding for better spacing
    const legendHeight = 50; // Increased legend space
    const totalHeight = (activities.length * barHeight) + padding + legendHeight;
    
    // Set minimum and maximum heights
    const minHeight = 200; // Increased minimum height
    const maxHeight = 800; // Increased maximum height
    const dynamicHeight = Math.max(minHeight, Math.min(maxHeight, totalHeight));
    
    // Update the container height
    chartContainer.style.height = dynamicHeight + 'px';
    
    // Prepare data for horizontal stacked bar chart
    const labels = activities.map(activity => {
        return activity.activity_name;
    });
    
    // Create datasets for each zone (horizontal bars)
    const datasets = zoneOrder.map(zone => {
        const data = activities.map(activity => {
            if (activity.presentation_buckets && activity.presentation_buckets[zone]) {
                return currentMetric === 'trimp' ? 
                    activity.presentation_buckets[zone].trimp : 
                    activity.presentation_buckets[zone].minutes;
            }
            return 0;
        });
        
        return {
            label: zone,
            data: data,
            backgroundColor: zoneColors[zone],
            borderColor: zoneColors[zone],
            borderWidth: 1,
            stack: 'activities'
        };
    });
    
    // Create the chart
    activitiesChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            indexAxis: 'y', // Horizontal bars
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const value = context.parsed.x;
                            const zone = context.dataset.label;
                            if (currentMetric === 'trimp') {
                                return `${zone}: ${value.toFixed(1)} TRIMP`;
                            } else {
                                return `${zone}: ${value.toFixed(0)} minutes`;
                            }
                        }
                    }
                },
                datalabels: {
                    display: false
                }
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP' : 'Minutes'
                    }
                },
                y: {
                    stacked: true
                }
            },
            elements: {
                bar: {
                    borderWidth: 1,
                    borderColor: '#ffffff'
                }
            }
        }
    });
}

// Create 24-hour heart rate chart
function createHeartRateChart(date, dayData) {
    console.log('Creating heart rate chart for date:', date);
    console.log('Day data:', dayData);
    
    const chartElement = document.getElementById('hrChart');
    const chartContainer = chartElement.parentElement;
    
    console.log('Chart element:', chartElement);
    console.log('Chart container:', chartContainer);
    console.log('Chart container dimensions:', chartContainer.offsetWidth, 'x', chartContainer.offsetHeight);
    console.log('Chart element dimensions:', chartElement.offsetWidth, 'x', chartElement.offsetHeight);
    
    const ctx = chartElement.getContext('2d');
    console.log('Chart context:', ctx);
    
    // Destroy existing chart if it exists
    if (hrChart) {
        hrChart.destroy();
    }
    
    // Check if we have raw heart rate data
    if (!dayData.raw_hr_data || !Array.isArray(dayData.raw_hr_data) || dayData.raw_hr_data.length === 0) {
        console.log('No raw heart rate data available');
        // No raw data available - show message
        hrChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Heart Rate',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    borderWidth: 2,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                scales: {
                    x: {
                        display: false
                    },
                    y: {
                        display: false
                    }
                }
            }
        });
        
        // Add a message overlay
        chartContainer.innerHTML = '<div class="d-flex align-items-center justify-content-center h-100"><p class="text-muted">No heart rate time-series data available</p></div>';
        return;
    }
    
    // Process raw heart rate data
    const hrData = dayData.raw_hr_data;
    console.log('Raw HR data length:', hrData.length);
    console.log('First few data points:', hrData.slice(0, 5));
    
    // Create evenly spaced 24-hour timeline (every 1 minute for high resolution)
    const labels = [];
    const data = [];
    
    // Get the date from the selected date
    const selectedDate = new Date(dayData.date);
    
    for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 1) {
            const timestamp = new Date(selectedDate);
            timestamp.setHours(hour, minute, 0, 0);
            labels.push(timestamp);
            data.push(null);
        }
    }
    
    // Sort data by timestamp
    const sortedData = hrData.sort((a, b) => {
        const timestampA = Array.isArray(a) ? a[0] : a.timestamp;
        const timestampB = Array.isArray(b) ? b[0] : b.timestamp;
        return timestampA - timestampB;
    });
    
    console.log('Sorted data length:', sortedData.length);
    
    // Map heart rate data to the 24-hour timeline
    sortedData.forEach(point => {
        let timestamp, hr;
        
        if (Array.isArray(point)) {
            // Format: [timestamp, value]
            timestamp = point[0];
            hr = point[1];
        } else {
            // Format: {"value": x, "timestamp": y}
            timestamp = point.timestamp;
            hr = point.value;
        }
        
        // Skip null values
        if (hr === null || hr === undefined) return;
        
        // Convert timestamp to Date object
        const date = new Date(timestamp);
        
        // Find the exact index in our labels array (1-minute precision)
        const hour = date.getHours();
        const minute = date.getMinutes();
        
        // Create a timestamp for comparison (same date, specific hour/minute)
        const comparisonTimestamp = new Date(selectedDate);
        comparisonTimestamp.setHours(hour, minute, 0, 0);
        
        const index = labels.findIndex(label => label.getTime() === comparisonTimestamp.getTime());
        if (index !== -1) {
            data[index] = hr;
        }
    });
    
    console.log('Processed labels length:', labels.length);
    console.log('Processed data length:', data.length);
    console.log('First few labels:', labels.slice(0, 5));
    console.log('First few data points:', data.slice(0, 5));
    
    // Filter out null values to keep only actual heart rate data
    const filteredLabels = [];
    const filteredData = [];
    
    for (let i = 0; i < labels.length; i++) {
        if (data[i] !== null) {
            filteredLabels.push(labels[i]);
            filteredData.push(data[i]);
        }
    }
    
    console.log('Filtered labels length:', filteredLabels.length);
    console.log('Filtered data length:', filteredData.length);
    console.log('First few filtered labels:', filteredLabels.slice(0, 5));
    console.log('First few filtered data points:', filteredData.slice(0, 5));
    
    // Small delay to ensure DOM is ready
    setTimeout(() => {
        // Create the chart
        hrChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels, // Use full 24-hour timeline for consistent x-axis
                datasets: [
                    // Single background dataset with gradient
                    {
                        label: 'Background',
                        data: labels.map(label => ({ x: label, y: 160 })), // Full height background for 24-hour timeline
                        borderColor: 'transparent',
                        backgroundColor: function(context) {
                            const chart = context.chart;
                            const {ctx, chartArea} = chart;
                            
                            if (!chartArea) {
                                return 'transparent';
                            }
                            
                            // Create gradient
                            const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                            
                            // Add color stops for each zone
                            gradient.addColorStop(0, '#e74c3c'); // 160+ Red
                            gradient.addColorStop(1/12, '#e74c3c'); // 150-159 Red
                            gradient.addColorStop(1/12, '#fd7e14'); // 150-159 Orange
                            gradient.addColorStop(1/6, '#fd7e14'); // 140-149 Orange
                            gradient.addColorStop(1/6, '#ffc107'); // 140-149 Yellow
                            gradient.addColorStop(3/12, '#ffc107'); // 130-139 Yellow
                            gradient.addColorStop(3/12, '#9acd32'); // 130-139 Yellow-green
                            gradient.addColorStop(1/3, '#9acd32'); // 120-129 Yellow-green
                            gradient.addColorStop(1/3, '#28a745'); // 120-129 Green
                            gradient.addColorStop(5/12, '#28a745'); // 110-119 Green
                            gradient.addColorStop(5/12, '#006d5b'); // 110-119 Deep teal
                            gradient.addColorStop(1/2, '#006d5b'); // 100-109 Deep teal
                            gradient.addColorStop(1/2, '#004080'); // 100-109 Night sky blue
                            gradient.addColorStop(7/12, '#004080'); // 90-99 Night sky blue
                            gradient.addColorStop(7/12, '#002040'); // 80-89 Midnight
                            gradient.addColorStop(2/3, '#002040'); // 80-89 Midnight
                            gradient.addColorStop(2/3, '#000000'); // 80-89 Black
                            gradient.addColorStop(1, '#000000'); // Below 80 Black
                            
                            return gradient;
                        },
                        borderWidth: 0,
                        fill: true,
                        tension: 0,
                        pointRadius: 0,
                        order: 1
                    },
                    // Heart rate line on top
                    {
                        label: 'Heart Rate (BPM)',
                        data: filteredLabels.map((label, index) => ({ x: label, y: filteredData[index] })), // Use filtered data with timestamps
                        borderColor: '#e74c3c',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        pointHoverBackgroundColor: '#e74c3c',
                        order: 0
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                // Get the raw timestamp from the data point
                                const rawData = context[0].raw;
                                if (rawData && rawData.x) {
                                    const date = new Date(rawData.x);
                                    const year = date.getFullYear();
                                    const month = String(date.getMonth() + 1).padStart(2, '0');
                                    const day = String(date.getDate()).padStart(2, '0');
                                    const hour = String(date.getHours()).padStart(2, '0');
                                    const minute = String(date.getMinutes()).padStart(2, '0');
                                    return `Time: ${year}-${month}-${day} ${hour}:${minute}`;
                                }
                                // Fallback to the label if raw data not available
                                return `Time: ${context[0].label}`;
                            },
                            label: function(context) {
                                // Only show tooltip for heart rate data, not background
                                if (context.dataset.label === 'Heart Rate (BPM)') {
                                    return `Heart Rate: ${context.parsed.y} BPM`;
                                }
                                return null; // Hide background dataset from tooltip
                            }
                        }
                    },
                    datalabels: {
                        display: false,
                        formatter: function() {
                            return ''; // Return empty string to ensure no labels
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour',
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        min: new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 0, 0, 0),
                        max: new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 23, 59, 0),
                        ticks: {
                            maxRotation: 0,
                            stepSize: 2,
                            source: 'auto'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Heart Rate (BPM)'
                        },
                        min: 40,
                        max: 160,
                        ticks: {
                            stepSize: 20
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });
        
        console.log('Chart created successfully:', hrChart);
        console.log('Chart dimensions after creation:', chartElement.offsetWidth, 'x', chartElement.offsetHeight);
    }, 100);
}
</script>
{% endblock %} 