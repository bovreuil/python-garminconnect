{% extends "base.html" %}

{% block title %}Dashboard - Garmin Heart Rate Analyzer{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1>Dashboard</h1>
            <div class="d-flex align-items-center gap-3">
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-primary" id="prevWeek">
                        <span>←</span>
                    </button>
                    <button type="button" class="btn btn-primary" id="todayBtn">Today</button>
                    <button type="button" class="btn btn-outline-primary" id="nextWeek">
                        <span>→</span>
                    </button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-secondary active" id="trimpBtn">TRIMP</button>
                    <button type="button" class="btn btn-outline-secondary" id="minutesBtn">Minutes</button>
                </div>
            </div>
        </div>
        
        <p class="text-muted mb-4">Welcome, {{ session.user_name }}! ({{ session.user_role }})</p>
    </div>
</div>

<!-- Two Week Chart Section -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Two Week Overview</h5>
                <small class="text-muted" id="dateRange"></small>
            </div>
            <div class="card-body">
                <div id="chartContainer" class="chart-container">
                    <canvas id="twoWeekChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Loading Indicator -->
<div id="loading" class="loading">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2">Loading data...</p>
</div>

<script>
// Register the DataLabels plugin
Chart.register(ChartDataLabels);

// Chart.js configuration
Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
Chart.defaults.font.size = 12;
Chart.defaults.color = '#2c3e50';

// Zone colors - temperature scale from cool to hot
const zoneColors = {
    '90-99': '#004080',    // Night sky blue
    '100-109': '#006d5b',  // Deep teal
    '110-119': '#28a745',  // Green
    '120-129': '#9acd32',  // Yellow-green
    '130-139': '#ffc107',  // Yellow
    '140-149': '#fd7e14',  // Orange
    '150-159': '#e74c3c',  // Red
    '160+': '#dc3545'      // Hot red
};

// Zone order for stacking (bottom to top)
const zoneOrder = [
    '90-99',
    '100-109', 
    '110-119',
    '120-129',
    '130-139',
    '140-149',
    '150-159',
    '160+'
];

let twoWeekChart = null;
let currentStartDate = null;
let currentEndDate = null;
let currentMetric = 'trimp'; // 'trimp' or 'minutes'

// Initialize the dashboard
document.addEventListener('DOMContentLoaded', function() {
    // Set up event listeners
    document.getElementById('prevWeek').addEventListener('click', () => navigateWeek(-1));
    document.getElementById('nextWeek').addEventListener('click', () => navigateWeek(1));
    document.getElementById('todayBtn').addEventListener('click', goToToday);
    document.getElementById('trimpBtn').addEventListener('click', () => switchMetric('trimp'));
    document.getElementById('minutesBtn').addEventListener('click', () => switchMetric('minutes'));
    
    // Start with today's view
    goToToday();
});

// Calculate the two-week period that includes today
function calculateTwoWeekPeriod(today) {
    // Find the Monday of the week that contains today
    const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Convert to Monday-based
    
    const mondayOfThisWeek = new Date(today);
    mondayOfThisWeek.setDate(today.getDate() - daysFromMonday);
    
    // The second week is the week that contains today (Monday to Sunday)
    // The first week is the week before that (Monday to Sunday)
    const startDate = new Date(mondayOfThisWeek);
    startDate.setDate(mondayOfThisWeek.getDate() - 7);
    
    const endDate = new Date(mondayOfThisWeek);
    endDate.setDate(mondayOfThisWeek.getDate() + 6);
    
    return { startDate, endDate };
}

// Navigate by one week
function navigateWeek(direction) {
    if (!currentStartDate || !currentEndDate) return;
    
    const newStartDate = new Date(currentStartDate);
    newStartDate.setDate(currentStartDate.getDate() + (direction * 7));
    
    const newEndDate = new Date(currentEndDate);
    newEndDate.setDate(currentEndDate.getDate() + (direction * 7));
    
    loadTwoWeekData(newStartDate, newEndDate);
}

// Go to today's two-week period
function goToToday() {
    const today = new Date();
    const { startDate, endDate } = calculateTwoWeekPeriod(today);
    loadTwoWeekData(startDate, endDate);
}

// Switch between TRIMP and minutes
function switchMetric(metric) {
    currentMetric = metric;
    
    // Update button states
    document.getElementById('trimpBtn').classList.toggle('active', metric === 'trimp');
    document.getElementById('minutesBtn').classList.toggle('active', metric === 'minutes');
    
    // Reload data with new metric
    if (currentStartDate && currentEndDate) {
        loadTwoWeekData(currentStartDate, currentEndDate);
    }
}

// Load two weeks of data
function loadTwoWeekData(startDate, endDate) {
    currentStartDate = startDate;
    currentEndDate = endDate;
    
    showLoading();
    updateDateRange();
    
    // Generate array of 14 dates
    const dates = [];
    const currentDate = new Date(startDate);
    for (let i = 0; i < 14; i++) {
        dates.push(new Date(currentDate));
        currentDate.setDate(currentDate.getDate() + 1);
    }
    
    // Load data for all dates
    Promise.all(dates.map(date => loadDateData(date)))
        .then(results => {
            updateTwoWeekChart(dates, results);
            hideLoading();
        })
        .catch(error => {
            console.error('Error loading two week data:', error);
            hideLoading();
        });
}

// Load data for a single date
function loadDateData(date) {
    const dateStr = date.toISOString().split('T')[0];
    
    return fetch(`/api/data/${dateStr}`)
        .then(response => {
            if (!response.ok) {
                // Return null for dates with no data
                return null;
            }
            return response.json();
        })
        .catch(error => {
            console.error(`Error loading data for ${dateStr}:`, error);
            return null;
        });
}

// Update the two-week chart
function updateTwoWeekChart(dates, dataResults) {
    const ctx = document.getElementById('twoWeekChart').getContext('2d');
    
    if (twoWeekChart) {
        twoWeekChart.destroy();
    }
    
    // Prepare data for stacked column chart
    const labels = dates.map(date => {
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const dayNum = date.getDate();
        return `${dayName} ${dayNum}`;
    });
    
    // Get all unique zones from the data
    const allZones = new Set();
    dataResults.forEach(data => {
        if (data && data.presentation_buckets) {
            Object.keys(data.presentation_buckets).forEach(zone => allZones.add(zone));
        }
    });
    
    // Sort zones according to our defined order (bottom to top)
    const sortedZones = zoneOrder.filter(zone => allZones.has(zone));
    
    // Create datasets for each zone in the correct order
    const datasets = sortedZones.map(zone => {
        const data = labels.map((_, index) => {
            const dayData = dataResults[index];
            if (!dayData || !dayData.presentation_buckets || !dayData.presentation_buckets[zone]) {
                return 0;
            }
            
            if (currentMetric === 'trimp') {
                return dayData.presentation_buckets[zone].trimp || 0;
            } else {
                return dayData.presentation_buckets[zone].minutes || 0;
            }
        });
        
        return {
            label: zone,
            data: data,
            backgroundColor: zoneColors[zone] || '#6c757d',
            borderWidth: 1,
            borderColor: '#ffffff'
        };
    });
    
    // Calculate the maximum value for Y-axis scaling
    let maxValue = 0;
    dataResults.forEach((dayData, index) => {
        if (dayData) {
            if (currentMetric === 'trimp') {
                maxValue = Math.max(maxValue, dayData.total_trimp || 0);
            } else {
                // Calculate total minutes for this day
                let totalMinutes = 0;
                if (dayData.presentation_buckets) {
                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                        totalMinutes += bucket.minutes || 0;
                    });
                }
                maxValue = Math.max(maxValue, totalMinutes);
            }
        }
    });
    
    // Calculate a proper max that aligns with Chart.js tick intervals
    let yAxisMax;
    if (maxValue === 0) {
        yAxisMax = 10; // Default for no data
    } else {
        // Determine step size based on the range
        let step;
        if (maxValue <= 50) step = 10;
        else if (maxValue <= 100) step = 20;
        else if (maxValue <= 200) step = 20;
        else if (maxValue <= 500) step = 50;
        else step = 100;
        
        // Add one extra step for label space
        yAxisMax = Math.ceil(maxValue / step) * step + step;
    }
    
    twoWeekChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP Score' : 'Minutes'
                    },
                    beginAtZero: true,
                    max: yAxisMax
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true
                    }
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(context) {
                            const dataIndex = context[0].dataIndex;
                            const dayData = dataResults[dataIndex];
                            if (dayData && dayData.total_trimp !== undefined) {
                                return `Total: ${dayData.total_trimp.toFixed(1)} TRIMP`;
                            }
                            return '';
                        }
                    }
                }
            },
            plugins: {
                datalabels: {
                    display: function(context) {
                        // Only show labels for the top dataset (last in the stack)
                        return context.datasetIndex === datasets.length - 1;
                    },
                    anchor: 'end',
                    align: 'top',
                    formatter: function(value, context) {
                        // Calculate total for this column
                        const dataIndex = context.dataIndex;
                        const dayData = dataResults[dataIndex];
                        if (dayData) {
                            if (currentMetric === 'trimp') {
                                return dayData.total_trimp ? dayData.total_trimp.toFixed(1) : '0';
                            } else {
                                // Calculate total minutes
                                let totalMinutes = 0;
                                if (dayData.presentation_buckets) {
                                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                                        totalMinutes += bucket.minutes || 0;
                                    });
                                }
                                return totalMinutes > 0 ? totalMinutes.toFixed(0) : '0';
                            }
                        }
                        return '0';
                    },
                    color: '#2c3e50',
                    font: {
                        weight: 'bold',
                        size: 11
                    },
                    offset: 4
                }
            }
        }
    });
}

// Update the date range display
function updateDateRange() {
    if (!currentStartDate || !currentEndDate) return;
    
    const startStr = currentStartDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
    });
    const endStr = currentEndDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
    });
    
    document.getElementById('dateRange').textContent = `${startStr} - ${endStr}`;
}

// Show/hide loading
function showLoading() {
    document.getElementById('loading').style.display = 'block';
}

function hideLoading() {
    document.getElementById('loading').style.display = 'none';
}
</script>
{% endblock %} 