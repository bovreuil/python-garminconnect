{% extends "base.html" %}

{% block title %}Dashboard - Garmin Heart Rate Analyzer{% endblock %}

{% block head %}
<script src="{{ url_for('static', filename='js/dashboard-navigation.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart-utilities.js') }}"></script>
<script src="{{ url_for('static', filename='js/data-loading.js') }}"></script>
<script src="{{ url_for('static', filename='js/heart-rate-charts.js') }}"></script>
<script src="{{ url_for('static', filename='js/breathing-charts.js') }}"></script>
<script src="{{ url_for('static', filename='js/spo2-charts.js') }}"></script>
<script src="{{ url_for('static', filename='js/view-management.js') }}"></script>
<script src="{{ url_for('static', filename='js/event-handlers.js') }}"></script>
<script src="{{ url_for('static', filename='js/modal-management.js') }}"></script>
<script src="{{ url_for('static', filename='js/notes-management.js') }}"></script>
<script src="{{ url_for('static', filename='js/utility-functions.js') }}"></script>
<script src="{{ url_for('static', filename='js/shared-data-functions.js') }}"></script>
<script src="{{ url_for('static', filename='js/page-initialization.js') }}"></script>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1>Welcome, {{ session.user_name }}!</h1>
            <div class="btn-group" role="group">
                <button type="button" class="btn btn-outline-secondary active" id="trimpBtn">TRIMP</button>
                <button type="button" class="btn btn-outline-secondary" id="minutesBtn">Minutes</button>
            </div>
        </div>
    </div>
</div>

<!-- 14 Week Chart Section -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0" id="fourteenWeekTitle">14 Week Overview</h5>
            </div>
            <div class="card-body">
                <div id="fourteenWeekChartContainer" class="chart-container" style="height: 360px;">
                    <canvas id="fourteenWeekChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Two Week Chart Section -->
<div class="row mt-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0" id="twoWeekTitle">Two Week Overview</h5>
                <div class="d-flex gap-2">
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-sm btn-outline-primary" id="prevWeek">
                            <span>←</span>
                        </button>
                        <button type="button" class="btn btn-sm btn-primary" id="todayBtn">Today</button>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="nextWeek">
                            <span>→</span>
                        </button>
                    </div>
                </div>
            </div>
            <div class="card-body">
                <div id="chartContainer" class="chart-container" style="height: 360px;">
                    <canvas id="twoWeekChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

{% include 'includes/single_date_view.html' %}

{% include 'includes/modals.html' %}

<script>
// Dashboard-specific initialization
let currentMetric = 'trimp'; // 'trimp' or 'minutes'

// Initialize the dashboard
document.addEventListener('DOMContentLoaded', function() {
    // Initialize common page elements
    initializePage();
    
    // Setup common event listeners
    setupCommonEventListeners();
    
    // Dashboard-specific event listeners
    document.getElementById('trimpBtn').addEventListener('click', () => switchMetric('trimp'));
    
    // Initialize by loading 14-week data and going to today
    loadFourteenWeekData();
    goToToday();
});



// navigateWeek moved to dashboard-navigation.js

// goToToday moved to dashboard-navigation.js

// navigateToWeek moved to dashboard-navigation.js

// navigateSingleDay moved to dashboard-navigation.js

// goToSingleDateToday moved to dashboard-navigation.js

// Switch between TRIMP and minutes
function switchMetric(metric) {
    currentMetric = metric;
    
    // Update button states
    document.getElementById('trimpBtn').classList.toggle('active', metric === 'trimp');
    document.getElementById('minutesBtn').classList.toggle('active', metric === 'minutes');
    
    // Reload 14-week data with new metric
    loadFourteenWeekData();
    
    // Reload two-week data with new metric
    if (currentStartDate && currentEndDate) {
        loadTwoWeekData(currentStartDate, currentEndDate);
    }
    
    // Update activities chart if single date view is open and we have a selected date
    const singleDateSection = document.getElementById('singleDateSection');
    if (singleDateSection.style.display !== 'none' && selectedDate) {
        loadActivitiesForDate(selectedDate);
    }
    
    // Update activity HR chart if single activity view is open and we have a selected activity
    const singleActivitySection = document.getElementById('singleActivitySection');
    if (singleActivitySection.style.display !== 'none' && selectedActivity) {
        createActivityHeartRateChart(selectedActivity);
    }
}

// loadTwoWeekData moved to shared-data-functions.js

// loadDateData moved to shared-data-functions.js

// Update the two-week chart
function updateTwoWeekChart(dateLabels, dataResults) {
    const ctx = document.getElementById('twoWeekChart').getContext('2d');
    
    if (twoWeekChart) {
        twoWeekChart.destroy();
    }
    
    // Prepare data for stacked column chart
    const labels = dateLabels.map(dateLabel => {
        // Create a Date object just for display formatting
        const date = new Date(dateLabel + 'T00:00:00');
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const dayNum = date.getDate();
        return `${dayName} ${dayNum}`;
    });
    
    // Get all unique zones from the data
    const allZones = new Set();
    dataResults.forEach(data => {
        if (data && data.presentation_buckets) {
            Object.keys(data.presentation_buckets).forEach(zone => allZones.add(zone));
        }
    });
    
    // Sort zones according to our defined order (bottom to top)
    const sortedZones = zoneOrder.filter(zone => allZones.has(zone));
    
    // Create datasets for each zone in the correct order
    const datasets = sortedZones.map(zone => {
        const data = labels.map((_, index) => {
            const dayData = dataResults[index];
            if (!dayData || !dayData.presentation_buckets || !dayData.presentation_buckets[zone]) {
                return 0;
            }
            
            if (currentMetric === 'trimp') {
                // Use override values if available, otherwise use calculated values
                if (dayData.trimp_overrides && dayData.trimp_overrides[zone] !== undefined) {
                    return dayData.trimp_overrides[zone];
                } else {
                    return dayData.presentation_buckets[zone].trimp || 0;
                }
            } else {
                // For minutes view, show 0 if overrides exist
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    return 0;
                } else {
                    return dayData.presentation_buckets[zone].minutes || 0;
                }
            }
        });
        
        return {
            label: zone,
            data: data,
            backgroundColor: zoneColors[zone] || '#6c757d',
            borderWidth: 1,
            borderColor: '#ffffff'
        };
    });
    
    // Calculate the maximum value for Y-axis scaling
    let maxValue = 0;
    dataResults.forEach((dayData, index) => {
        if (dayData) {
            if (currentMetric === 'trimp') {
                // Use override total if available, otherwise use calculated total
                let trimpTotal = dayData.total_trimp || 0;
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    trimpTotal = Object.values(dayData.trimp_overrides).reduce((sum, value) => sum + value, 0);
                }
                maxValue = Math.max(maxValue, trimpTotal);
            } else {
                // Calculate total minutes for this day (0 if overrides exist)
                let totalMinutes = 0;
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    totalMinutes = 0;
                } else if (dayData.presentation_buckets) {
                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                        totalMinutes += bucket.minutes || 0;
                    });
                }
                maxValue = Math.max(maxValue, totalMinutes);
            }
        }
    });
    
    // Calculate Y-axis maximum using shared utility (with 500 minimum for consistency)
    const { axisMax: yAxisMax } = calculateAxisScaling(maxValue, true, 500);
    
    twoWeekChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = twoWeekChart.chartArea;
                if (!chartArea) return;
                
                // Check if click is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    
                    // Calculate which date column was clicked based on x-coordinate
                    const xAxis = twoWeekChart.scales.x;
                    const clickIndex = xAxis.getValueForPixel(x);
                    
                    if (clickIndex >= 0 && clickIndex < dateLabels.length) {
                        const dateLabel = dateLabels[clickIndex];
                        // Reload the data for this specific date to ensure we have the latest overrides
                        loadDateData(dateLabel).then(dayData => {
                            showSingleDateView(dateLabel, dayData);
                        });
                    }
                }
            },
            onHover: function(event, elements) {
                event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Date'
                    },
                    ticks: {
                        callback: function(value, index) {
                            // Make labels clickable by adding a click handler
                            const label = this.getLabelForValue(value);
                            return label;
                        }
                    }
                },
                y: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP Score' : 'Minutes'
                    },
                    beginAtZero: true,
                    max: yAxisMax
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true
                    }
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(context) {
                            const dataIndex = context[0].dataIndex;
                            const dayData = dataResults[dataIndex];
                            if (dayData && dayData.total_trimp !== undefined) {
                                return `Total: ${dayData.total_trimp.toFixed(1)} TRIMP`;
                            }
                            return '';
                        }
                    }
                }
            },
            plugins: {
                datalabels: {
                    display: function(context) {
                        // Only show labels for the top dataset (last in the stack)
                        return context.datasetIndex === datasets.length - 1;
                    },
                    anchor: 'end',
                    align: 'top',
                    formatter: function(value, context) {
                        // Calculate total for this column
                        const dataIndex = context.dataIndex;
                        const dayData = dataResults[dataIndex];
                        if (dayData) {
                            if (currentMetric === 'trimp') {
                                return dayData.total_trimp ? dayData.total_trimp.toFixed(1) : '0';
                            } else {
                                // Calculate total minutes
                                let totalMinutes = 0;
                                if (dayData.presentation_buckets) {
                                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                                        totalMinutes += bucket.minutes || 0;
                                    });
                                }
                                return totalMinutes > 0 ? totalMinutes.toFixed(0) : '0';
                            }
                        }
                        return '0';
                    },
                    color: '#2c3e50',
                    font: {
                        weight: 'bold',
                        size: 11
                    },
                    offset: 4
                }
            }
        }
    });
}

// updateDateRange moved to dashboard-navigation.js

// Load 14 weeks of data
function loadFourteenWeekData() {
    showLoading();
    
    // Calculate the 14-week period ending with the current week
    const today = new Date();
    const currentWeekStart = getWeekStart(today);
    const fourteenWeekStart = new Date(currentWeekStart);
    fourteenWeekStart.setDate(currentWeekStart.getDate() - (13 * 7)); // Go back 13 weeks
    
    // Generate array of 98 date labels (14 weeks × 7 days)
    const dateLabels = [];
    const currentDate = new Date(fourteenWeekStart);
    for (let i = 0; i < 98; i++) {
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getDate()).padStart(2, '0');
        dateLabels.push(`${year}-${month}-${day}`);
        currentDate.setDate(currentDate.getDate() + 1);
    }
    
    // Load data for all date labels using batch API
    fetch('/api/data/batch', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ dates: dateLabels })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Convert batch response to array format expected by chart
            const results = dateLabels.map(dateLabel => data.data[dateLabel] || null);
            updateFourteenWeekChart(dateLabels, results);
        } else {
            console.error('Error loading 14 week data:', data.error);
        }
        hideLoading();
    })
    .catch(error => {
        console.error('Error loading 14 week data:', error);
        hideLoading();
    });
}

// Get the start of the week (Monday) for a given date
// getWeekStart moved to dashboard-navigation.js

// Update 14-week chart
function updateFourteenWeekChart(dateLabels, dataResults) {
    const ctx = document.getElementById('fourteenWeekChart').getContext('2d');
    
    // Destroy existing chart if it exists
    if (fourteenWeekChart) {
        fourteenWeekChart.destroy();
    }
    
    // Group data by week (Monday to Sunday)
    const weeklyData = [];
    const weekLabels = [];
    
    for (let week = 0; week < 14; week++) {
        const weekStart = week * 7;
        const weekEnd = weekStart + 7;
        const weekDates = dateLabels.slice(weekStart, weekEnd);
        const weekData = dataResults.slice(weekStart, weekEnd);
        
        // Aggregate data for this week
        const weekAggregated = aggregateWeekData(weekData);
        weeklyData.push(weekAggregated);
        
        // Create week label (e.g., "Apr 7")
        const firstDate = new Date(weekDates[0] + 'T00:00:00');
        const weekLabel = firstDate.toLocaleDateString('en-US', { 
            month: 'short', 
            day: 'numeric' 
        });
        weekLabels.push(weekLabel);
    }
    
    // Create datasets for each zone
    const datasets = zoneOrder.map(zone => ({
        label: zone,
        data: weeklyData.map(weekData => weekData[zone] || 0),
        backgroundColor: zoneColors[zone],
        borderColor: zoneColors[zone],
        borderWidth: 1
    }));
    
    // Calculate the maximum value for Y-axis scaling
    let maxValue = 0;
    weeklyData.forEach(weekData => {
        const weekTotal = Object.values(weekData).reduce((sum, value) => sum + value, 0);
        maxValue = Math.max(maxValue, weekTotal);
    });
    
    // Calculate Y-axis maximum using shared utility (no minimum constraint for 14-week)
    const { axisMax: yAxisMax } = calculateAxisScaling(maxValue, true);
    
    fourteenWeekChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: weekLabels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = fourteenWeekChart.chartArea;
                if (!chartArea) return;
                
                // Check if click is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    
                    // Calculate which week column was clicked based on x-coordinate
                    const xAxis = fourteenWeekChart.scales.x;
                    const clickIndex = xAxis.getValueForPixel(x);
                    
                    if (clickIndex >= 0 && clickIndex < weekLabels.length) {
                        // Get the week start date (Monday) for this week
                        const weekStartDate = new Date(dateLabels[clickIndex * 7]);
                        const monday = getWeekStart(weekStartDate);
                        
                        // Navigate to this week in the two-week view
                        navigateToWeek(monday);
                    }
                }
            },
            onHover: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = fourteenWeekChart.chartArea;
                if (!chartArea) return;
                
                // Check if hover is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'default';
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(context) {
                            const weekIndex = context[0].dataIndex;
                            const weekData = weeklyData[weekIndex];
                            const total = Object.values(weekData).reduce((sum, value) => sum + value, 0);
                            return `Total: ${total.toFixed(1)}`;
                        }
                    }
                },
                datalabels: {
                    display: function(context) {
                        // Only show labels for the top dataset (last in the stack)
                        return context.datasetIndex === datasets.length - 1;
                    },
                    anchor: 'end',
                    align: 'top',
                    formatter: function(value, context) {
                        // Calculate total for this week
                        const weekIndex = context.dataIndex;
                        const weekData = weeklyData[weekIndex];
                        const total = Object.values(weekData).reduce((sum, value) => sum + value, 0);
                        return total > 0 ? total.toFixed(1) : '0';
                    },
                    color: '#2c3e50',
                    font: {
                        weight: 'bold',
                        size: 11
                    },
                    offset: 4
                }
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Week Starting'
                    }
                },
                y: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP' : 'Minutes'
                    },
                    max: yAxisMax
                }
            }
        }
    });
    
    // Update the 14-week title with the date range
    const startDate = new Date(dateLabels[0] + 'T00:00:00');
    const endDate = new Date(dateLabels[dateLabels.length - 1] + 'T00:00:00');
    const startStr = startDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
    });
    const endStr = endDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
    });
    
    document.getElementById('fourteenWeekTitle').textContent = `${startStr} - ${endStr}`;
}

// Aggregate data for a week
function aggregateWeekData(weekData) {
    const aggregated = {};
    
    // Initialize all zones with 0
    zoneOrder.forEach(zone => {
        aggregated[zone] = 0;
    });
    
    // Aggregate data for each day in the week
    weekData.forEach(dayData => {
        if (dayData) {
            if (currentMetric === 'trimp') {
                // Handle TRIMP data
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    // Use override values
                    Object.keys(dayData.trimp_overrides).forEach(zone => {
                        if (zoneOrder.includes(zone)) {
                            aggregated[zone] += dayData.trimp_overrides[zone] || 0;
                        }
                    });
                } else if (dayData.presentation_buckets) {
                    // Use calculated TRIMP values
                    Object.keys(dayData.presentation_buckets).forEach(zone => {
                        if (zoneOrder.includes(zone)) {
                            aggregated[zone] += dayData.presentation_buckets[zone].trimp || 0;
                        }
                    });
                }
            } else {
                // Handle minutes data
                if (dayData.presentation_buckets) {
                    const hasOverrides = dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0;
                    if (!hasOverrides) {
                        Object.keys(dayData.presentation_buckets).forEach(zone => {
                            if (zoneOrder.includes(zone)) {
                                aggregated[zone] += dayData.presentation_buckets[zone].minutes || 0;
                            }
                        });
                    }
                }
            }
        }
    });
    
    return aggregated;
}

// Show/hide loading
// showLoading and hideLoading moved to dashboard-navigation.js (already available)

// showSingleDateView and closeSingleDateView functions moved to view-management.js

// showSingleActivityView and closeSingleActivityView functions moved to view-management.js

// All utility functions moved to shared modules:
// - downloadActivityCsv, downloadDailyCsv -> utility-functions.js
// - openSpo2Editor, saveSpo2Data, etc. -> modal-management.js  
// - loadDailyNotes, editDailyNotes, etc. -> notes-management.js
// - loadDailySpo2Distribution, toggleSpo2ChartType, etc. -> utility-functions.js

// downloadActivityCsv and downloadDailyCsv moved to shared-data-functions.js

// SpO2 Editor Functions moved to modal-management.js

// SpO2 Editor Functions moved to modal-management.js

// TRIMP Editor Functions moved to modal-management.js

// TRIMP Editor Functions moved to modal-management.js

// Manual Activity Functions moved to modal-management.js

// CSV Upload Functions moved to modal-management.js

// loadActivitiesForDate moved to shared-data-functions.js

// Create horizontal bar chart for activities
function createActivitiesChart(activities) {
    const ctx = document.getElementById('activitiesChart').getContext('2d');
    const chartContainer = document.getElementById('activitiesChartContainer');
    
    // Destroy existing chart if it exists
    if (activitiesChart) {
        activitiesChart.destroy();
    }
    
    if (!activities || activities.length === 0) {
        // No activities - show empty chart with message
        chartContainer.style.height = '100px'; // Small height for empty state
        
        // Clear any existing overlay
        const existingOverlay = chartContainer.querySelector('.no-activities-overlay');
        if (existingOverlay) {
            existingOverlay.remove();
        }
        
        activitiesChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                scales: {
                    x: {
                        display: false
                    },
                    y: {
                        display: false
                    }
                }
            }
        });
        
        // Add a message overlay without destroying the canvas
        const overlay = document.createElement('div');
        overlay.className = 'no-activities-overlay d-flex align-items-center justify-content-center h-100';
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        overlay.innerHTML = '<p class="text-muted">No activities for this date</p>';
        chartContainer.appendChild(overlay);
        return;
    }
    
    // Clear any existing overlay
    const existingOverlay = chartContainer.querySelector('.no-activities-overlay');
    if (existingOverlay) {
        existingOverlay.remove();
    }
    
    // Calculate dynamic height based on number of activities
    // Each bar should be about 40px thick, plus some padding for labels and spacing
    const barHeight = 56;
    const padding = 40;
    const legendHeight = 50;
    const totalHeight = (activities.length * barHeight) + padding + legendHeight;
        
    // Update the container height
    chartContainer.style.height = totalHeight + 'px';
    
    // Prepare data for horizontal stacked bar chart
    const labels = activities.map(activity => {
        return activity.activity_name;
    });
    
    // Create datasets for each zone (horizontal bars)
    const datasets = zoneOrder.map(zone => {
        const data = activities.map(activity => {
            if (activity.presentation_buckets && activity.presentation_buckets[zone]) {
                return currentMetric === 'trimp' ? 
                    activity.presentation_buckets[zone].trimp : 
                    activity.presentation_buckets[zone].minutes;
            }
            return 0;
        });
        
        return {
            label: zone,
            data: data,
            backgroundColor: zoneColors[zone],
            borderColor: zoneColors[zone],
            borderWidth: 1,
            stack: 'activities'
        };
    });
    
    // Calculate x-axis maximum with minimum of 100
    let maxValue = 0;
    activities.forEach(activity => {
        if (activity.presentation_buckets) {
            let activityTotal = 0;
            Object.values(activity.presentation_buckets).forEach(bucket => {
                activityTotal += currentMetric === 'trimp' ? (bucket.trimp || 0) : (bucket.minutes || 0);
            });
            maxValue = Math.max(maxValue, activityTotal);
        }
    });
    
    // Calculate x-axis maximum using shared utility
    const xAxisMax = calculateAxisMaxWithMinimum(maxValue, 100);
    
    // Create the chart
    activitiesChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            indexAxis: 'y', // Horizontal bars
            responsive: true,
            maintainAspectRatio: false,
            onClick: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = activitiesChart.chartArea;
                if (!chartArea) return;
                
                // Check if click is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    
                    // Calculate which activity row was clicked based on y-coordinate
                    const yAxis = activitiesChart.scales.y;
                    const clickIndex = yAxis.getValueForPixel(y);
                    
                    if (clickIndex >= 0 && clickIndex < activities.length) {
                        const activity = activities[clickIndex];
                        showSingleActivityView(activity);
                    }
                }
            },
            onHover: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = activitiesChart.chartArea;
                if (!chartArea) {
                    event.native.target.style.cursor = 'default';
                    return;
                }
                
                // Check if hover is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    event.native.target.style.cursor = 'pointer';
                } else {
                    event.native.target.style.cursor = 'default';
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    mode: 'nearest',
                    intersect: false,
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const value = context.parsed.x;
                            const zone = context.dataset.label;
                            if (currentMetric === 'trimp') {
                                return `${zone}: ${value.toFixed(1)} TRIMP`;
                            } else {
                                return `${zone}: ${value.toFixed(0)} minutes`;
                            }
                        }
                    }
                },
                datalabels: {
                    display: false
                }
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP' : 'Minutes'
                    },
                    max: xAxisMax
                },
                y: {
                    stacked: true
                }
            },
            elements: {
                bar: {
                    borderWidth: 1,
                    borderColor: '#ffffff'
                }
            }
        }
    });
}

// Create SpO2 chart for daily view
// createSpo2Chart function moved to chart-creation.js

// Create SpO2 chart for activity view
// createActivitySpo2Chart function moved to chart-creation.js

// Create breathing chart for activity view
// createActivityBreathingChart function moved to chart-creation.js

// Create 24-hour heart rate chart
// createHeartRateChart function moved to chart-creation.js

// Create activity heart rate chart
// createActivityHeartRateChart function moved to chart-creation.js

// Notes Functions moved to notes-management.js

// SpO2 Distribution Functions moved to utility-functions.js


</script>
{% endblock %} 