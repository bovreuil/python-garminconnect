{% extends "base.html" %}

{% block title %}Dashboard - Garmin Heart Rate Analyzer{% endblock %}

{% block head %}

{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1>Welcome, {{ session.user_name }}!</h1>
            <div class="btn-group" role="group">
                <button type="button" class="btn btn-outline-secondary active" id="trimpBtn">TRIMP</button>
                <button type="button" class="btn btn-outline-secondary" id="minutesBtn">Minutes</button>
            </div>
        </div>
    </div>
</div>

<!-- 14 Week Chart Section -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0" id="fourteenWeekTitle">14 Week Overview</h5>
            </div>
            <div class="card-body">
                <div id="fourteenWeekChartContainer" class="chart-container" style="height: 360px;">
                    <canvas id="fourteenWeekChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Two Week Chart Section -->
<div class="row mt-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0" id="twoWeekTitle">Two Week Overview</h5>
                <div class="d-flex gap-2">
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-sm btn-outline-primary" id="prevWeek">
                            <span>‚Üê</span>
                        </button>
                        <button type="button" class="btn btn-sm btn-primary" id="todayBtn">Today</button>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="nextWeek">
                            <span>‚Üí</span>
                        </button>
                    </div>
                </div>
            </div>
            <div class="card-body">
                <div id="chartContainer" class="chart-container" style="height: 360px;">
                    <canvas id="twoWeekChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Single Date View Section -->
<div class="row mt-4" id="singleDateSection" style="display: none;">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center">
                    <h5 class="mb-0" id="singleDateTitle">Single Date View</h5>
                </div>
                <div class="d-flex gap-2">
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-sm btn-outline-primary" id="prevDay">
                            <span>‚Üê</span>
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="nextDay">
                            <span>‚Üí</span>
                        </button>
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-primary" id="downloadDailyCsv">
                        <span>üì• CSV</span>
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-info" id="createManualActivityBtn">
                        <span>‚ûï Manual</span>
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-warning" id="editTrimp">
                        <span id="trimpIcon">üìä</span>
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="closeSingleDate">
                        <span>√ó</span>
                    </button>
                </div>
            </div>
            <div class="card-body">
                <!-- 24-Hour Heart Rate Chart -->
                <div class="row mb-4">
                    <div class="col-12">
                        <h6>24-Hour Heart Rate</h6>
                        <div id="spo2ChartContainer" class="chart-container" style="height: 0px; margin-bottom: 5px; display: none;">
                            <canvas id="spo2Chart"></canvas>
                        </div>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="hrChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="row mb-4">
                    <div class="col-md-6">
                        <h6 id="selectedDateTitle">Day Summary</h6>
                        <div id="dateDetails">
                            <p class="text-muted">Click on a column above to view details</p>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6>Heart Rate Zones</h6>
                        <div id="zoneBreakdown">
                            <p class="text-muted">Zone breakdown will appear here</p>
                        </div>
                    </div>
                </div>
                
                <!-- Activities Chart -->
                <div class="row mb-4">
                    <div class="col-12">
                        <h6>Activities</h6>
                        <div class="chart-container" id="activitiesChartContainer" style="height: 280px;">
                            <canvas id="activitiesChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- Single Activity View Section -->
                <div class="row mt-4" id="singleActivitySection" style="display: none;">
                    <div class="col-12">
                        <div class="card">
                                        <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0" id="singleActivityTitle">Single Activity View</h5>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-sm btn-outline-danger" id="deleteActivity" style="display: none;">
                                        <span>üóëÔ∏è Delete</span>
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-primary" id="downloadActivityCsv">
                                        <span>üì• CSV</span>
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-warning" id="uploadActivityCsv">
                                        <span id="csvIcon">üì§ CSV</span>
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-info" id="editSpo2">
                                        <span>ü©∏ SpO2</span>
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="closeSingleActivity">
                                        <span>√ó</span>
                                    </button>
                                </div>
                            </div>
                            <div class="card-body">
                                <!-- Activity Heart Rate Chart -->
                                <div class="row mb-4">
                                    <div class="col-12">
                                        <h6 id="activityTitle">Activity Heart Rate</h6>
                                        <div id="activitySpo2ChartContainer" class="chart-container" style="height: 0px; margin-bottom: 5px; display: none;">
                                            <canvas id="activitySpo2Chart"></canvas>
                                        </div>
                                        <div class="chart-container" style="height: 300px;">
                                            <canvas id="activityHrChart"></canvas>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Activity Summary -->
                                <div class="row mb-4">
                                    <div class="col-md-6">
                                        <h6>Activity Summary</h6>
                                        <div id="activitySummary">
                                            <p class="text-muted">Activity summary will appear here</p>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <h6>Heart Rate Zones</h6>
                                        <div id="activityZoneBreakdown">
                                            <p class="text-muted">Zone breakdown will appear here</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Loading Indicator -->
<div id="loading" class="loading">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2">Loading data...</p>
</div>

<!-- SpO2 Editor Modal -->
<div class="modal fade" id="spo2Modal" tabindex="-1" aria-labelledby="spo2ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="spo2ModalLabel">Edit SpO2 Data</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <p class="text-muted">Enter SpO2 readings with time offsets from activity start. Use MM:SS format for time (e.g., 5:30 for 5 minutes 30 seconds).</p>
                </div>
                
                <div class="mb-3">
                    <button type="button" class="btn btn-sm btn-outline-primary" id="addSpo2Entry">
                        <span>+ Add Entry</span>
                    </button>
                </div>
                
                <div id="spo2Entries">
                    <!-- SpO2 entries will be added here dynamically -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveSpo2">Save SpO2 Data</button>
            </div>
        </div>
    </div>
</div>

<!-- TRIMP Editor Modal -->
<div class="modal fade" id="trimpModal" tabindex="-1" aria-labelledby="trimpModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="trimpModalLabel">Edit TRIMP Overrides</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <p class="text-muted">Enter TRIMP values for each heart rate zone. Leave fields empty to use calculated values. Total will be calculated automatically.</p>
                </div>
                
                <div id="trimpOverridesForm">
                    <!-- TRIMP override fields will be added here dynamically -->
                </div>
                
                <div class="mt-3">
                    <div class="row">
                        <div class="col-md-6">
                            <h6>Total TRIMP: <span id="totalTrimpOverride">0.0</span></h6>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-outline-danger" id="clearTrimpOverrides">Clear Overrides</button>
                <button type="button" class="btn btn-primary" id="saveTrimpOverrides">Save TRIMP Overrides</button>
            </div>
        </div>
    </div>
</div>

<!-- CSV Upload Modal -->
<div class="modal fade" id="csvUploadModal" tabindex="-1" aria-labelledby="csvUploadModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="csvUploadModalLabel">Upload HR CSV Data</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <p class="text-muted">Upload a CSV file with corrected heart rate data. The file should have two columns: timestamp and hr. This will override the activity's original HR data.</p>
                </div>
                
                <div class="mb-3">
                    <label for="csvFile" class="form-label">Select CSV File</label>
                    <input type="file" class="form-control" id="csvFile" accept=".csv">
                </div>
                
                <div class="alert alert-info">
                    <strong>Instructions:</strong>
                    <ul class="mb-0">
                        <li>Download the current CSV first to see the format</li>
                        <li>Edit the HR values in your preferred spreadsheet software</li>
                        <li>Save as CSV and upload here</li>
                        <li>The system will recalculate TRIMP and update all views</li>
                    </ul>
                </div>
                
                <div id="csvStatus" class="mt-3">
                    <!-- Status messages will appear here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-outline-danger" id="clearCsvOverride">Clear Override</button>
                <button type="button" class="btn btn-primary" id="uploadCsv">Upload CSV</button>
            </div>
        </div>
    </div>
</div>

<!-- Manual Activity Modal -->
<div class="modal fade" id="manualActivityModal" tabindex="-1" aria-labelledby="manualActivityModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="manualActivityModalLabel">Create Manual Activity</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <p class="text-muted">Create a manual activity to override heart rate data for a specific time period. This will generate a heart rate time series with 30-second intervals.</p>
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <label for="manualStartTime" class="form-label">Start Time (HH:MM)</label>
                        <input type="text" class="form-control" id="manualStartTime" placeholder="14:30" pattern="^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$">
                    </div>
                    <div class="col-md-6">
                        <label for="manualEndTime" class="form-label">End Time (HH:MM)</label>
                        <input type="text" class="form-control" id="manualEndTime" placeholder="15:00" pattern="^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$">
                    </div>
                </div>
                
                <div class="mb-3">
                    <label for="manualHeartRate" class="form-label">Heart Rate</label>
                    <input type="number" class="form-control" id="manualHeartRate" placeholder="85" min="0" max="300">
                </div>
                
                <div class="alert alert-info">
                    <small>
                        <strong>Example:</strong> If you have 4 minutes of crazy HR data from 14:30-14:34, 
                        you can create a manual activity from 14:30-14:34 with HR 85 to replace the crazy data.
                    </small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="createManualActivity">Create Activity</button>
            </div>
        </div>
    </div>
</div>

<script>
// Register the DataLabels plugin
Chart.register(ChartDataLabels);

// Add CSS for notes fields
const style = document.createElement('style');
style.textContent = `
    .notes-field {
        padding: 0.5rem;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        cursor: pointer;
        min-height: 2.5rem;
        transition: all 0.2s ease-in-out;
    }
    
    .notes-field:hover {
        background-color: #e9ecef;
        border-color: #adb5bd;
    }
    
    .notes-field p {
        margin: 0;
        min-height: 1.5rem;
    }
`;
document.head.appendChild(style);



// Helper function to format dates consistently without timezone issues
function formatDateForAPI(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Calculate two-week period containing a given date
// preferSecondWeek: if true, puts target date in second week (for initialization)
// if false, puts target date in first week (for minimal navigation)
function calculateTwoWeekPeriod(targetDate, preferSecondWeek = true) {
    const startDate = new Date(targetDate);
    const endDate = new Date(targetDate);
    
    // Find the Monday of the week containing the target date
    const dayOfWeek = startDate.getDay();
    const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Sunday = 0, Monday = 1
    startDate.setDate(startDate.getDate() - daysToMonday);
    
    if (preferSecondWeek) {
        // Move back one week so the target date is in the second week
        startDate.setDate(startDate.getDate() - 7);
    }
    
    // Set end date to 13 days after start (14 days total)
    endDate.setDate(startDate.getDate() + 13);
    
    return { startDate, endDate };
}



// Chart.js configuration
Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
Chart.defaults.font.size = 12;
Chart.defaults.color = '#2c3e50';

// Zone colors - temperature scale from cool to hot
const zoneColors = {
    '80-89': '#002040',    // Midnight
    '90-99': '#004080',    // Night sky blue
    '100-109': '#006d5b',  // Deep teal
    '110-119': '#28a745',  // Green
    '120-129': '#9acd32',  // Yellow-green
    '130-139': '#ffc107',  // Yellow
    '140-149': '#fd7e14',  // Orange
    '150-159': '#e74c3c',  // Red
    '160+': '#dc3545'      // Hot red
};

// SpO2 zone colors
const spo2ZoneColors = {
    '80-82.5': '#dc3545',   // Hot red
    '82.5-85': '#dc3545',   // Hot red
    '85-87.5': '#e74c3c',   // Red
    '87.5-90': '#fd7e14',   // Orange
    '90-92.5': '#ffc107',   // Yellow
    '92.5-95': '#9acd32',   // Yellow-green
    '95-97.5': '#28a745',   // Green
    '97.5-100': '#28a745'   // Green
};

// Zone order for stacking (bottom to top)
const zoneOrder = [
    '80-89',
    '90-99',
    '100-109', 
    '110-119',
    '120-129',
    '130-139',
    '140-149',
    '150-159',
    '160+'
];

let twoWeekChart = null;
let fourteenWeekChart = null;
let hrChart = null;
let spo2Chart = null;
let activitiesChart = null;
let activityHrChart = null;
let activitySpo2Chart = null;
let currentStartDate = null;
let currentEndDate = null;
let currentMetric = 'trimp'; // 'trimp' or 'minutes'
let currentDataResults = []; // Store the current data results for click handling
let selectedDate = null; // Track the currently selected date for single date view
let selectedActivity = null; // Track the currently selected activity

    // Initialize the dashboard
    document.addEventListener('DOMContentLoaded', function() {
        // Add window resize listener to keep charts aligned
        window.addEventListener('resize', function() {
            setTimeout(() => {
                if (spo2Chart && hrChart) {
                    const hrContainer = document.querySelector('.chart-container canvas#hrChart').parentElement;
                    const spo2Container = document.querySelector('.chart-container canvas#spo2Chart').parentElement;
                    if (hrContainer && spo2Container) {
                        spo2Container.style.width = hrContainer.offsetWidth + 'px';
                        spo2Chart.resize();
                    }
                }
                if (activitySpo2Chart && activityHrChart) {
                    const hrContainer = document.querySelector('.chart-container canvas#activityHrChart').parentElement;
                    const spo2Container = document.querySelector('.chart-container canvas#activitySpo2Chart').parentElement;
                    if (hrContainer && spo2Container) {
                        spo2Container.style.width = hrContainer.offsetWidth + 'px';
                        activitySpo2Chart.resize();
                    }
                }
            }, 100);
        });
    // Set up event listeners
    document.getElementById('prevWeek').addEventListener('click', () => navigateWeek(-1));
    document.getElementById('nextWeek').addEventListener('click', () => navigateWeek(1));
    document.getElementById('todayBtn').addEventListener('click', goToToday);
    document.getElementById('prevDay').addEventListener('click', () => navigateSingleDay(-1));
    document.getElementById('nextDay').addEventListener('click', () => navigateSingleDay(1));
    document.getElementById('trimpBtn').addEventListener('click', () => switchMetric('trimp'));
    document.getElementById('minutesBtn').addEventListener('click', () => switchMetric('minutes'));
    document.getElementById('closeSingleDate').addEventListener('click', closeSingleDateView);
    document.getElementById('closeSingleActivity').addEventListener('click', closeSingleActivityView);
    document.getElementById('downloadActivityCsv').addEventListener('click', downloadActivityCsv);
    document.getElementById('downloadDailyCsv').addEventListener('click', downloadDailyCsv);
    document.getElementById('editSpo2').addEventListener('click', openSpo2Editor);
    document.getElementById('addSpo2Entry').addEventListener('click', addSpo2Entry);
    document.getElementById('saveSpo2').addEventListener('click', saveSpo2Data);
    document.getElementById('editTrimp').addEventListener('click', openTrimpEditor);
    document.getElementById('saveTrimpOverrides').addEventListener('click', saveTrimpOverrides);
    document.getElementById('clearTrimpOverrides').addEventListener('click', clearTrimpOverrides);
    
    // Manual activity event handlers
    document.getElementById('createManualActivityBtn').addEventListener('click', openManualActivityModal);
    document.getElementById('createManualActivity').addEventListener('click', createManualActivity);
    document.getElementById('uploadActivityCsv').addEventListener('click', openCsvUploadEditor);
    document.getElementById('uploadCsv').addEventListener('click', uploadCsvData);
    document.getElementById('deleteActivity').addEventListener('click', function() {
        if (selectedActivity) {
            deleteActivity(selectedActivity.activity_id);
        }
    });
    document.getElementById('clearCsvOverride').addEventListener('click', clearCsvOverride);
    
    // Initialize by loading 14-week data and going to today
    loadFourteenWeekData();
    goToToday();
});



// Navigate by one week
function navigateWeek(direction) {
    if (!currentStartDate || !currentEndDate) return;
    
    // Close single date view and single activity view when navigating
    closeSingleDateView();
    closeSingleActivityView();
    
    // Calculate new start and end dates
    const newStartDate = new Date(currentStartDate);
    const newEndDate = new Date(currentEndDate);
    newStartDate.setDate(currentStartDate.getDate() + (direction * 7));
    newEndDate.setDate(currentEndDate.getDate() + (direction * 7));
    
    loadTwoWeekData(newStartDate, newEndDate);
}

// Go to today's two-week period
function goToToday() {
    // Close single date view and single activity view when going to today
    closeSingleDateView();
    closeSingleActivityView();
    
    const today = new Date();
    const { startDate, endDate } = calculateTwoWeekPeriod(today);
    
    loadTwoWeekData(startDate, endDate);
    
    // Also open single day view for today
    const todayString = today.toISOString().split('T')[0];
    loadDateData(todayString).then(dayData => {
        showSingleDateView(todayString, dayData);
    });
}

// Navigate to a specific week in the two-week view
function navigateToWeek(targetDate) {
    // Close single date view and single activity view when navigating
    closeSingleDateView();
    closeSingleActivityView();
    
    // Calculate the two-week period with the target date in the second week
    const { startDate, endDate } = calculateTwoWeekPeriod(targetDate, true);
    
    loadTwoWeekData(startDate, endDate);
}

// Navigate single day left or right
function navigateSingleDay(direction) {
    if (!selectedDate) {
        return;
    }
    
    // Close single activity view when navigating
    closeSingleActivityView();
    
    // Convert selectedDate string to Date object
    const currentDate = new Date(selectedDate + 'T00:00:00');
    const newDate = new Date(currentDate);
    newDate.setDate(currentDate.getDate() + direction);
    
    // Check if the new date is outside the current period
    if (currentStartDate && currentEndDate) {
        if (newDate < currentStartDate || newDate > currentEndDate) {
            // Need to adjust the period
            // When going left (direction < 0): prefer first week to see more past dates
            // When going right (direction > 0): prefer second week to see more future dates
            const preferSecondWeek = direction > 0;
            const { startDate, endDate } = calculateTwoWeekPeriod(newDate, preferSecondWeek);
            loadTwoWeekData(startDate, endDate);
        }
    }
    
    // Show the single day view for the new date
    setTimeout(() => {
        loadDateData(formatDateForAPI(newDate)).then(dayData => {
            // Always show the single day view, even if there's no data
            showSingleDateView(formatDateForAPI(newDate), dayData);
        });
    }, 500);
}

// Switch between TRIMP and minutes
function switchMetric(metric) {
    currentMetric = metric;
    
    // Update button states
    document.getElementById('trimpBtn').classList.toggle('active', metric === 'trimp');
    document.getElementById('minutesBtn').classList.toggle('active', metric === 'minutes');
    
    // Reload 14-week data with new metric
    loadFourteenWeekData();
    
    // Reload two-week data with new metric
    if (currentStartDate && currentEndDate) {
        loadTwoWeekData(currentStartDate, currentEndDate);
    }
    
    // Update activities chart if single date view is open and we have a selected date
    const singleDateSection = document.getElementById('singleDateSection');
    if (singleDateSection.style.display !== 'none' && selectedDate) {
        loadActivitiesForDate(selectedDate);
    }
    
    // Update activity HR chart if single activity view is open and we have a selected activity
    const singleActivitySection = document.getElementById('singleActivitySection');
    if (singleActivitySection.style.display !== 'none' && selectedActivity) {
        createActivityHeartRateChart(selectedActivity);
    }
}

// Load two weeks of data
function loadTwoWeekData(startDate, endDate) {
    // Normalize dates to start of day to avoid time component issues
    currentStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    currentEndDate = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
    
    showLoading();
    updateDateRange();
    
    // Generate array of 14 date labels (strings, not Date objects)
    const dateLabels = [];
    const currentDate = new Date(startDate);
    for (let i = 0; i < 14; i++) {
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getDate()).padStart(2, '0');
        dateLabels.push(`${year}-${month}-${day}`);
        currentDate.setDate(currentDate.getDate() + 1);
    }
    
    // Load data for all date labels
    Promise.all(dateLabels.map(dateLabel => loadDateData(dateLabel)))
        .then(results => {
            currentDataResults = results; // Store for click handling
            updateTwoWeekChart(dateLabels, results);
            hideLoading();
        })
        .catch(error => {
            console.error('Error loading two week data:', error);
            hideLoading();
        });
}

// Load data for a single date label (string)
function loadDateData(dateLabel) {
    console.log(`Loading data for ${dateLabel}`);
    
    return fetch(`/api/data/${dateLabel}`)
        .then(response => {
            if (!response.ok) {
                // Return null for dates with no data
                return null;
            }
            return response.json();
        })
        .then(data => {
            if (data) {
                
                // Load TRIMP overrides for this date
                return fetch(`/api/data/${dateLabel}/trimp-overrides`)
                    .then(response => response.json())
                    .then(overridesData => {
                        if (overridesData.success && overridesData.trimp_overrides && Object.keys(overridesData.trimp_overrides).length > 0) {
                            // Apply TRIMP overrides (even if all values are 0)
                            data.trimp_overrides = overridesData.trimp_overrides;
                            
                            // Update total TRIMP if we're viewing TRIMP metric
                            if (currentMetric === 'trimp') {
                                let totalOverride = 0;
                                Object.values(overridesData.trimp_overrides).forEach(value => {
                                    totalOverride += value;
                                });
                                data.total_trimp = totalOverride;
                            }
                            
                            // For minutes view, set minutes to 0 when overrides exist
                            if (currentMetric === 'minutes' && data.presentation_buckets) {
                                Object.keys(data.presentation_buckets).forEach(zone => {
                                    data.presentation_buckets[zone].minutes = 0;
                                });
                            }
                        }
                        return data;
                    })
                    .catch(error => {
                        console.error(`Error loading TRIMP overrides for ${dateLabel}:`, error);
                        return data;
                    });
            } else {
                // Check for TRIMP overrides even when there's no HR data
                return fetch(`/api/data/${dateLabel}/trimp-overrides`)
                    .then(response => response.json())
                    .then(overridesData => {
                        if (overridesData.success && overridesData.trimp_overrides && Object.keys(overridesData.trimp_overrides).length > 0) {
                            // Create minimal data structure with overrides
                            const overrideData = {
                                total_trimp: Object.values(overridesData.trimp_overrides).reduce((sum, value) => sum + value, 0),
                                trimp_overrides: overridesData.trimp_overrides,
                                presentation_buckets: {} // Empty buckets for zones
                            };
                            
                            // Create empty buckets for all zones
                            zoneOrder.forEach(zone => {
                                overrideData.presentation_buckets[zone] = {
                                    minutes: 0,
                                    trimp: 0
                                };
                            });
                            
                            return overrideData;
                        }
                        return null;
                    })
                    .catch(error => {
                        console.error(`Error loading TRIMP overrides for ${dateLabel}:`, error);
                        return null;
                    });
            }
        })
        .catch(error => {
            console.error(`Error loading data for ${dateLabel}:`, error);
            return null;
        });
}

// Update the two-week chart
function updateTwoWeekChart(dateLabels, dataResults) {
    const ctx = document.getElementById('twoWeekChart').getContext('2d');
    
    if (twoWeekChart) {
        twoWeekChart.destroy();
    }
    
    // Prepare data for stacked column chart
    const labels = dateLabels.map(dateLabel => {
        // Create a Date object just for display formatting
        const date = new Date(dateLabel + 'T00:00:00');
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const dayNum = date.getDate();
        return `${dayName} ${dayNum}`;
    });
    
    // Get all unique zones from the data
    const allZones = new Set();
    dataResults.forEach(data => {
        if (data && data.presentation_buckets) {
            Object.keys(data.presentation_buckets).forEach(zone => allZones.add(zone));
        }
    });
    
    // Sort zones according to our defined order (bottom to top)
    const sortedZones = zoneOrder.filter(zone => allZones.has(zone));
    
    // Create datasets for each zone in the correct order
    const datasets = sortedZones.map(zone => {
        const data = labels.map((_, index) => {
            const dayData = dataResults[index];
            if (!dayData || !dayData.presentation_buckets || !dayData.presentation_buckets[zone]) {
                return 0;
            }
            
            if (currentMetric === 'trimp') {
                // Use override values if available, otherwise use calculated values
                if (dayData.trimp_overrides && dayData.trimp_overrides[zone] !== undefined) {
                    return dayData.trimp_overrides[zone];
                } else {
                    return dayData.presentation_buckets[zone].trimp || 0;
                }
            } else {
                // For minutes view, show 0 if overrides exist
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    return 0;
                } else {
                    return dayData.presentation_buckets[zone].minutes || 0;
                }
            }
        });
        
        return {
            label: zone,
            data: data,
            backgroundColor: zoneColors[zone] || '#6c757d',
            borderWidth: 1,
            borderColor: '#ffffff'
        };
    });
    
    // Calculate the maximum value for Y-axis scaling
    let maxValue = 0;
    dataResults.forEach((dayData, index) => {
        if (dayData) {
            if (currentMetric === 'trimp') {
                // Use override total if available, otherwise use calculated total
                let trimpTotal = dayData.total_trimp || 0;
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    trimpTotal = Object.values(dayData.trimp_overrides).reduce((sum, value) => sum + value, 0);
                }
                maxValue = Math.max(maxValue, trimpTotal);
            } else {
                // Calculate total minutes for this day (0 if overrides exist)
                let totalMinutes = 0;
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    totalMinutes = 0;
                } else if (dayData.presentation_buckets) {
                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                        totalMinutes += bucket.minutes || 0;
                    });
                }
                maxValue = Math.max(maxValue, totalMinutes);
            }
        }
    });
    
    // Calculate a proper max that aligns with Chart.js tick intervals
    let yAxisMax;
    if (maxValue === 0) {
        yAxisMax = 500; // Default minimum for consistency
    } else {
        // Determine step size based on the range
        let step;
        if (maxValue <= 50) step = 10;
        else if (maxValue <= 100) step = 20;
        else if (maxValue <= 200) step = 20;
        else if (maxValue <= 500) step = 50;
        else step = 100;
        
        // Add one extra step for label space
        yAxisMax = Math.ceil(maxValue / step) * step + step;
        
        // Ensure minimum y-axis maximum of 500 for consistency across weeks
        yAxisMax = Math.max(yAxisMax, 500);
    }
    
    twoWeekChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = twoWeekChart.chartArea;
                if (!chartArea) return;
                
                // Check if click is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    
                    // Calculate which date column was clicked based on x-coordinate
                    const xAxis = twoWeekChart.scales.x;
                    const clickIndex = xAxis.getValueForPixel(x);
                    
                    if (clickIndex >= 0 && clickIndex < dateLabels.length) {
                        const dateLabel = dateLabels[clickIndex];
                        // Reload the data for this specific date to ensure we have the latest overrides
                        loadDateData(dateLabel).then(dayData => {
                            showSingleDateView(dateLabel, dayData);
                        });
                    }
                }
            },
            onHover: function(event, elements) {
                event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Date'
                    },
                    ticks: {
                        callback: function(value, index) {
                            // Make labels clickable by adding a click handler
                            const label = this.getLabelForValue(value);
                            return label;
                        }
                    }
                },
                y: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP Score' : 'Minutes'
                    },
                    beginAtZero: true,
                    max: yAxisMax
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true
                    }
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(context) {
                            const dataIndex = context[0].dataIndex;
                            const dayData = dataResults[dataIndex];
                            if (dayData && dayData.total_trimp !== undefined) {
                                return `Total: ${dayData.total_trimp.toFixed(1)} TRIMP`;
                            }
                            return '';
                        }
                    }
                }
            },
            plugins: {
                datalabels: {
                    display: function(context) {
                        // Only show labels for the top dataset (last in the stack)
                        return context.datasetIndex === datasets.length - 1;
                    },
                    anchor: 'end',
                    align: 'top',
                    formatter: function(value, context) {
                        // Calculate total for this column
                        const dataIndex = context.dataIndex;
                        const dayData = dataResults[dataIndex];
                        if (dayData) {
                            if (currentMetric === 'trimp') {
                                return dayData.total_trimp ? dayData.total_trimp.toFixed(1) : '0';
                            } else {
                                // Calculate total minutes
                                let totalMinutes = 0;
                                if (dayData.presentation_buckets) {
                                    Object.values(dayData.presentation_buckets).forEach(bucket => {
                                        totalMinutes += bucket.minutes || 0;
                                    });
                                }
                                return totalMinutes > 0 ? totalMinutes.toFixed(0) : '0';
                            }
                        }
                        return '0';
                    },
                    color: '#2c3e50',
                    font: {
                        weight: 'bold',
                        size: 11
                    },
                    offset: 4
                }
            }
        }
    });
}

// Update the date range display
function updateDateRange() {
    if (!currentStartDate || !currentEndDate) return;
    
    const startStr = currentStartDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
    });
    const endStr = currentEndDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
    });
    
    // Update the two week title with the date range
    document.getElementById('twoWeekTitle').textContent = `${startStr} - ${endStr}`;
}

// Load 14 weeks of data
function loadFourteenWeekData() {
    showLoading();
    
    // Calculate the 14-week period ending with the current week
    const today = new Date();
    const currentWeekStart = getWeekStart(today);
    const fourteenWeekStart = new Date(currentWeekStart);
    fourteenWeekStart.setDate(currentWeekStart.getDate() - (13 * 7)); // Go back 13 weeks
    
    // Generate array of 98 date labels (14 weeks √ó 7 days)
    const dateLabels = [];
    const currentDate = new Date(fourteenWeekStart);
    for (let i = 0; i < 98; i++) {
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getDate()).padStart(2, '0');
        dateLabels.push(`${year}-${month}-${day}`);
        currentDate.setDate(currentDate.getDate() + 1);
    }
    
    // Load data for all date labels
    Promise.all(dateLabels.map(dateLabel => loadDateData(dateLabel)))
        .then(results => {
            updateFourteenWeekChart(dateLabels, results);
            hideLoading();
        })
        .catch(error => {
            console.error('Error loading 14 week data:', error);
            hideLoading();
        });
}

// Get the start of the week (Monday) for a given date
function getWeekStart(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
    return new Date(d.setDate(diff));
}

// Update 14-week chart
function updateFourteenWeekChart(dateLabels, dataResults) {
    const ctx = document.getElementById('fourteenWeekChart').getContext('2d');
    
    // Destroy existing chart if it exists
    if (fourteenWeekChart) {
        fourteenWeekChart.destroy();
    }
    
    // Group data by week (Monday to Sunday)
    const weeklyData = [];
    const weekLabels = [];
    
    for (let week = 0; week < 14; week++) {
        const weekStart = week * 7;
        const weekEnd = weekStart + 7;
        const weekDates = dateLabels.slice(weekStart, weekEnd);
        const weekData = dataResults.slice(weekStart, weekEnd);
        
        // Aggregate data for this week
        const weekAggregated = aggregateWeekData(weekData);
        weeklyData.push(weekAggregated);
        
        // Create week label (e.g., "Apr 7")
        const firstDate = new Date(weekDates[0] + 'T00:00:00');
        const weekLabel = firstDate.toLocaleDateString('en-US', { 
            month: 'short', 
            day: 'numeric' 
        });
        weekLabels.push(weekLabel);
    }
    
    // Create datasets for each zone
    const datasets = zoneOrder.map(zone => ({
        label: zone,
        data: weeklyData.map(weekData => weekData[zone] || 0),
        backgroundColor: zoneColors[zone],
        borderColor: zoneColors[zone],
        borderWidth: 1
    }));
    
    // Calculate the maximum value for Y-axis scaling
    let maxValue = 0;
    weeklyData.forEach(weekData => {
        const weekTotal = Object.values(weekData).reduce((sum, value) => sum + value, 0);
        maxValue = Math.max(maxValue, weekTotal);
    });
    
    // Calculate a proper max that aligns with Chart.js tick intervals
    let yAxisMax;
    if (maxValue === 0) {
        yAxisMax = 10; // Default for no data
    } else {
        // Determine step size based on the range
        let step;
        if (maxValue <= 50) step = 10;
        else if (maxValue <= 100) step = 20;
        else if (maxValue <= 200) step = 20;
        else if (maxValue <= 500) step = 50;
        else if (maxValue <= 1000) step = 100;
        else if (maxValue <= 2000) step = 200;
        else if (maxValue <= 5000) step = 500;
        else step = 1000;
        
        // Add one extra step for label space
        yAxisMax = Math.ceil(maxValue / step) * step + step;
    }
    
    fourteenWeekChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: weekLabels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = fourteenWeekChart.chartArea;
                if (!chartArea) return;
                
                // Check if click is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    
                    // Calculate which week column was clicked based on x-coordinate
                    const xAxis = fourteenWeekChart.scales.x;
                    const clickIndex = xAxis.getValueForPixel(x);
                    
                    if (clickIndex >= 0 && clickIndex < weekLabels.length) {
                        // Get the week start date (Monday) for this week
                        const weekStartDate = new Date(dateLabels[clickIndex * 7]);
                        const monday = getWeekStart(weekStartDate);
                        
                        // Navigate to this week in the two-week view
                        navigateToWeek(monday);
                    }
                }
            },
            onHover: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = fourteenWeekChart.chartArea;
                if (!chartArea) return;
                
                // Check if hover is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'default';
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(context) {
                            const weekIndex = context[0].dataIndex;
                            const weekData = weeklyData[weekIndex];
                            const total = Object.values(weekData).reduce((sum, value) => sum + value, 0);
                            return `Total: ${total.toFixed(1)}`;
                        }
                    }
                },
                datalabels: {
                    display: function(context) {
                        // Only show labels for the top dataset (last in the stack)
                        return context.datasetIndex === datasets.length - 1;
                    },
                    anchor: 'end',
                    align: 'top',
                    formatter: function(value, context) {
                        // Calculate total for this week
                        const weekIndex = context.dataIndex;
                        const weekData = weeklyData[weekIndex];
                        const total = Object.values(weekData).reduce((sum, value) => sum + value, 0);
                        return total > 0 ? total.toFixed(1) : '0';
                    },
                    color: '#2c3e50',
                    font: {
                        weight: 'bold',
                        size: 11
                    },
                    offset: 4
                }
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Week Starting'
                    }
                },
                y: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP' : 'Minutes'
                    },
                    max: yAxisMax
                }
            }
        }
    });
    
    // Update the 14-week title with the date range
    const startDate = new Date(dateLabels[0] + 'T00:00:00');
    const endDate = new Date(dateLabels[dateLabels.length - 1] + 'T00:00:00');
    const startStr = startDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
    });
    const endStr = endDate.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
    });
    
    document.getElementById('fourteenWeekTitle').textContent = `${startStr} - ${endStr}`;
}

// Aggregate data for a week
function aggregateWeekData(weekData) {
    const aggregated = {};
    
    // Initialize all zones with 0
    zoneOrder.forEach(zone => {
        aggregated[zone] = 0;
    });
    
    // Aggregate data for each day in the week
    weekData.forEach(dayData => {
        if (dayData) {
            if (currentMetric === 'trimp') {
                // Handle TRIMP data
                if (dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0) {
                    // Use override values
                    Object.keys(dayData.trimp_overrides).forEach(zone => {
                        if (zoneOrder.includes(zone)) {
                            aggregated[zone] += dayData.trimp_overrides[zone] || 0;
                        }
                    });
                } else if (dayData.presentation_buckets) {
                    // Use calculated TRIMP values
                    Object.keys(dayData.presentation_buckets).forEach(zone => {
                        if (zoneOrder.includes(zone)) {
                            aggregated[zone] += dayData.presentation_buckets[zone].trimp || 0;
                        }
                    });
                }
            } else {
                // Handle minutes data
                if (dayData.presentation_buckets) {
                    const hasOverrides = dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0;
                    if (!hasOverrides) {
                        Object.keys(dayData.presentation_buckets).forEach(zone => {
                            if (zoneOrder.includes(zone)) {
                                aggregated[zone] += dayData.presentation_buckets[zone].minutes || 0;
                            }
                        });
                    }
                }
            }
        }
    });
    
    return aggregated;
}

// Show/hide loading
function showLoading() {
    document.getElementById('loading').style.display = 'block';
}

function hideLoading() {
    document.getElementById('loading').style.display = 'none';
}

// Show single date view
function showSingleDateView(dateLabel, dayData) {
    // Close single activity view when switching to a different date
    closeSingleActivityView();
    
    selectedDate = dateLabel; // Store the selected date label globally
    

    
    // Create a Date object just for display formatting
    const date = new Date(dateLabel + 'T00:00:00');
    const dateDisplayStr = date.toLocaleDateString('en-US', { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    });
    
    // Update the single date title with the formatted date
    document.getElementById('singleDateTitle').textContent = dateDisplayStr;
    document.getElementById('selectedDateTitle').textContent = 'Day Summary';
    
    if (!dayData) {
        document.getElementById('dateDetails').innerHTML = '<p class="text-muted">No data available for this date</p>';
        document.getElementById('zoneBreakdown').innerHTML = '<p class="text-muted">No zone data available</p>';
        // Clear heart rate chart
            if (hrChart) {
        hrChart.destroy();
        hrChart = null;
    }
    if (spo2Chart) {
        spo2Chart.destroy();
        spo2Chart = null;
    }
    } else {
        // Create 24-hour heart rate chart
        createHeartRateChart(dateLabel, dayData);
        
        // Display date details
        let detailsHtml = '<div class="row">';
        
        if (dayData.total_trimp !== undefined) {
            const hasOverrides = dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0;
            const trimpValue = hasOverrides ? 
                Object.values(dayData.trimp_overrides).reduce((sum, value) => sum + value, 0) : 
                dayData.total_trimp;
            const trimpLabel = hasOverrides ? 'Override TRIMP' : 'Total TRIMP';
            
            detailsHtml += `
                <div class="col-6">
                    <div class="text-center p-3 bg-light rounded">
                        <h4 class="text-primary mb-1">${trimpValue.toFixed(1)}</h4>
                        <small class="text-muted">${trimpLabel}</small>
                    </div>
                </div>
            `;
        }
        
        if (dayData.presentation_buckets) {
            const hasOverrides = dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0;
            let totalMinutes = 0;
            
            if (!hasOverrides) {
                Object.values(dayData.presentation_buckets).forEach(bucket => {
                    totalMinutes += bucket.minutes || 0;
                });
            }
            
            detailsHtml += `
                <div class="col-6">
                    <div class="text-center p-3 bg-light rounded">
                        <h4 class="text-success mb-1">${totalMinutes.toFixed(0)}</h4>
                        <small class="text-muted">Total Minutes</small>
                    </div>
                </div>
            `;
        }
        
        detailsHtml += '</div>';
        
        // Add notes section
        detailsHtml += `
            <div class="mt-3">
                <h6 class="mb-2">Notes</h6>
                <div id="dailyNotes" class="notes-field" onclick="editDailyNotes('${dateLabel}')">
                    <p class="mb-0"></p>
                </div>
            </div>
        `;
        
        document.getElementById('dateDetails').innerHTML = detailsHtml;
        
            // Load notes for this date
    loadDailyNotes(dateLabel);
    
    // Check for TRIMP overrides and update icon
    checkTrimpOverrides(dateLabel);
        
        // Display zone breakdown
        if (dayData.presentation_buckets) {
            let zoneHtml = '<div class="table-responsive"><table class="table table-sm">';
            zoneHtml += '<thead><tr><th>Zone</th><th>Minutes</th><th>TRIMP</th><th>%</th></tr></thead><tbody>';
            
            const sortedZones = zoneOrder.filter(zone => dayData.presentation_buckets[zone]).reverse();
            let totalMinutes = 0;
            let totalTrimp = 0;
            
            // Calculate totals first
            sortedZones.forEach(zone => {
                const bucket = dayData.presentation_buckets[zone];
                totalMinutes += bucket.minutes || 0;
                totalTrimp += bucket.trimp || 0;
            });
            
            // Check if TRIMP overrides are active
            const hasOverrides = dayData.trimp_overrides && Object.keys(dayData.trimp_overrides).length > 0;
            
            // Display each zone
            sortedZones.forEach(zone => {
                const bucket = dayData.presentation_buckets[zone];
                const minutes = hasOverrides ? 0 : (bucket.minutes || 0);
                const trimp = hasOverrides ? (dayData.trimp_overrides[zone] || 0) : (bucket.trimp || 0);
                const percentage = totalMinutes > 0 ? ((minutes / totalMinutes) * 100).toFixed(1) : '0.0';
                
                // Use grey color if overrides are active, otherwise use zone color
                const badgeColor = hasOverrides ? '#6c757d' : zoneColors[zone];
                
                zoneHtml += `
                    <tr>
                        <td>
                            <span class="badge" style="background-color: ${badgeColor}; color: white;">${zone}</span>
                        </td>
                        <td>${minutes.toFixed(0)}</td>
                        <td>${trimp.toFixed(1)}</td>
                        <td>${percentage}%</td>
                    </tr>
                `;
            });
            
            zoneHtml += '</tbody></table></div>';
            document.getElementById('zoneBreakdown').innerHTML = zoneHtml;
        } else {
            document.getElementById('zoneBreakdown').innerHTML = '<p class="text-muted">No zone data available</p>';
        }
    }
    
    // Show the section
    document.getElementById('singleDateSection').style.display = 'block';
    
    // Load and display activities for this date
    loadActivitiesForDate(dateLabel);
    
    // Scroll to the section
    document.getElementById('singleDateSection').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start' 
    });
}

// Close single date view
function closeSingleDateView() {
    document.getElementById('singleDateSection').style.display = 'none';
    selectedDate = null; // Clear the selected date
    
    // Destroy activities chart if it exists
    if (activitiesChart) {
        activitiesChart.destroy();
        activitiesChart = null;
    }
}

// Show single activity view
function showSingleActivityView(activity) {
    selectedActivity = activity; // Store the selected activity globally
    

    
    // Create a Date object for display formatting
    const activityDate = new Date(selectedDate + 'T00:00:00');
    const activityDateStr = activityDate.toLocaleDateString('en-US', { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    });
    
    // Update the single activity title with date and activity name
    document.getElementById('singleActivityTitle').textContent = `${activityDateStr} - ${activity.activity_name}`;
    document.getElementById('activityTitle').textContent = 'Activity Heart Rate';
    
    // Show the section
    document.getElementById('singleActivitySection').style.display = 'block';
    
    // Show/hide delete button for manual activities
    const deleteBtn = document.getElementById('deleteActivity');
    if (activity.activity_type === 'manual') {
        deleteBtn.style.display = 'inline-block';
    } else {
        deleteBtn.style.display = 'none';
    }
    
    // Small delay to ensure DOM is fully updated before creating chart
    setTimeout(() => {
        // Create the activity heart rate chart
        createActivityHeartRateChart(activity);
    }, 50);
    
    // Display activity summary
    let summaryHtml = '<div class="row">';
    
    if (activity.total_trimp !== undefined) {
        summaryHtml += `
            <div class="col-6">
                <div class="text-center p-3 bg-light rounded">
                    <h4 class="text-primary mb-1">${activity.total_trimp.toFixed(1)}</h4>
                    <small class="text-muted">Total TRIMP</small>
                </div>
            </div>
        `;
    }
    
    if (activity.presentation_buckets) {
        let totalMinutes = 0;
        Object.values(activity.presentation_buckets).forEach(bucket => {
            totalMinutes += bucket.minutes || 0;
        });
        
        summaryHtml += `
            <div class="col-6">
                <div class="text-center p-3 bg-light rounded">
                    <h4 class="text-success mb-1">${totalMinutes.toFixed(0)}</h4>
                    <small class="text-muted">Total Minutes</small>
                </div>
            </div>
        `;
    }
    
    summaryHtml += '</div>';
    document.getElementById('activitySummary').innerHTML = summaryHtml;
    
    // Display zone breakdown
    if (activity.presentation_buckets) {
        let zoneHtml = '<div class="table-responsive"><table class="table table-sm">';
        zoneHtml += '<thead><tr><th>Zone</th><th>Minutes</th><th>TRIMP</th><th>%</th></tr></thead><tbody>';
        
        const sortedZones = zoneOrder.filter(zone => activity.presentation_buckets[zone]).reverse();
        let totalMinutes = 0;
        let totalTrimp = 0;
        
        // Calculate totals first
        sortedZones.forEach(zone => {
            const bucket = activity.presentation_buckets[zone];
            totalMinutes += bucket.minutes || 0;
            totalTrimp += bucket.trimp || 0;
        });
        
        // Display each zone
        sortedZones.forEach(zone => {
            const bucket = activity.presentation_buckets[zone];
            const minutes = bucket.minutes || 0;
            const trimp = bucket.trimp || 0;
            const percentage = totalMinutes > 0 ? ((minutes / totalMinutes) * 100).toFixed(1) : '0.0';
            
            zoneHtml += `
                <tr>
                    <td>
                        <span class="badge" style="background-color: ${zoneColors[zone]}; color: white;">${zone}</span>
                    </td>
                    <td>${minutes.toFixed(0)}</td>
                    <td>${trimp.toFixed(1)}</td>
                    <td>${percentage}%</td>
                </tr>
            `;
        });
        
        zoneHtml += '</tbody></table></div>';
        document.getElementById('activityZoneBreakdown').innerHTML = zoneHtml;
    } else {
        document.getElementById('activityZoneBreakdown').innerHTML = '<p class="text-muted">No zone data available</p>';
    }
    
    // Add notes section to activity summary
    let notesHtml = `
        <div class="mt-3">
            <h6 class="mb-2">Notes</h6>
            <div id="activityNotes" class="notes-field" onclick="editActivityNotes('${activity.activity_id}')">
                <p class="mb-0"></p>
            </div>
        </div>
    `;
    document.getElementById('activitySummary').insertAdjacentHTML('beforeend', notesHtml);
    
    // Load notes for this activity
    loadActivityNotes(activity.activity_id);

    // Remove any previous notes section after the zone breakdown (cleanup)
    const oldNotes = document.getElementById('activityZoneBreakdown')?.nextElementSibling;
    if (oldNotes && oldNotes.id === 'activityNotes') {
        oldNotes.parentNode.removeChild(oldNotes);
    }
    
    // Scroll to the section
    document.getElementById('singleActivitySection').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start' 
    });
}

// Close single activity view
function closeSingleActivityView() {
    document.getElementById('singleActivitySection').style.display = 'none';
    selectedActivity = null; // Clear the selected activity
    

    
    // Destroy activity HR chart if it exists
    if (activityHrChart) {
        activityHrChart.destroy();
        activityHrChart = null;
    }
    if (activitySpo2Chart) {
        activitySpo2Chart.destroy();
        activitySpo2Chart = null;
    }
    
    // Clear the chart container to ensure clean state
    const chartContainer = document.querySelector('#singleActivitySection .chart-container');
    if (chartContainer) {
        chartContainer.innerHTML = '<canvas id="activityHrChart"></canvas>';
    }
}

// Download activity HR data as CSV
function downloadActivityCsv() {
    if (!selectedActivity) {
        console.error('No activity selected for download');
        return;
    }
    
    const activityId = selectedActivity.activity_id;
    const downloadUrl = `/api/activity/${activityId}/hr-csv`;
    
    // Create a temporary link element to trigger the download
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = `activity_${activityId}_hr_data.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Download daily HR data as CSV
function downloadDailyCsv() {
    if (!selectedDate) {
        console.error('No date selected for download');
        return;
    }
    
    const downloadUrl = `/api/data/${selectedDate}/hr-csv`;
    
    // Create a temporary link element to trigger the download
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = `daily_${selectedDate}_hr_data.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// SpO2 Editor Functions
let spo2Entries = [];

function openSpo2Editor() {
    if (!selectedActivity) {
        console.error('No activity selected for SpO2 editing');
        return;
    }
    
    // Load existing SpO2 data if available
    spo2Entries = [];
    if (selectedActivity.spo2_values && selectedActivity.spo2_values.length > 0) {
        // Convert existing SpO2 data to entries format
        const firstHrTimestamp = selectedActivity.heart_rate_values[0][0];
        selectedActivity.spo2_values.forEach(spo2Point => {
            const timeOffsetMs = spo2Point[0] - firstHrTimestamp;
            const minutes = Math.floor(timeOffsetMs / 60000);
            const seconds = Math.floor((timeOffsetMs % 60000) / 1000);
            const timeOffset = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            spo2Entries.push({
                time_offset: timeOffset,
                spo2_value: spo2Point[1]
            });
        });
    }
    
    // Populate the modal
    populateSpo2Entries();
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('spo2Modal'));
    modal.show();
}

function addSpo2Entry() {
    let defaultTime = '0:00';
    
    // If there are existing entries, calculate the next time (15 seconds after the last entry)
    if (spo2Entries.length > 0) {
        const lastEntry = spo2Entries[spo2Entries.length - 1];
        if (lastEntry.time_offset && lastEntry.time_offset.match(/^\d+:\d{2}$/)) {
            const [minutes, seconds] = lastEntry.time_offset.split(':').map(Number);
            let totalSeconds = minutes * 60 + seconds + 15; // Add 15 seconds
            const newMinutes = Math.floor(totalSeconds / 60);
            const newSeconds = totalSeconds % 60;
            defaultTime = `${newMinutes}:${newSeconds.toString().padStart(2, '0')}`;
        }
    }
    
    spo2Entries.push({
        time_offset: defaultTime,
        spo2_value: ''
    });
    populateSpo2Entries();
}

function removeSpo2Entry(index) {
    spo2Entries.splice(index, 1);
    populateSpo2Entries();
}

function populateSpo2Entries() {
    const container = document.getElementById('spo2Entries');
    container.innerHTML = '';
    
    spo2Entries.forEach((entry, index) => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'row mb-2 align-items-center';
        entryDiv.innerHTML = `
            <div class="col-5">
                <input type="text" class="form-control" placeholder="MM:SS" 
                       value="${entry.time_offset}" 
                       onchange="updateSpo2Entry(${index}, 'time_offset', this.value)">
            </div>
            <div class="col-5">
                <input type="number" class="form-control" placeholder="SpO2 %" min="0" max="100"
                       value="${entry.spo2_value}" 
                       onchange="updateSpo2Entry(${index}, 'spo2_value', parseInt(this.value))">
            </div>
            <div class="col-2">
                <button type="button" class="btn btn-sm btn-outline-danger" onclick="removeSpo2Entry(${index})">
                    <span>√ó</span>
                </button>
            </div>
        `;
        container.appendChild(entryDiv);
    });
}

function updateSpo2Entry(index, field, value) {
    if (index >= 0 && index < spo2Entries.length) {
        spo2Entries[index][field] = value;
    }
}

function saveSpo2Data() {
    if (!selectedActivity) {
        console.error('No activity selected for saving SpO2 data');
        return;
    }
    
    // Validate entries
    const validEntries = spo2Entries.filter(entry => 
        entry.time_offset && entry.time_offset.match(/^\d+:\d{2}$/) && 
        entry.spo2_value !== '' && entry.spo2_value >= 0 && entry.spo2_value <= 100
    );
    
    // Allow empty entries - this will clear the SpO2 data
    
    // Send data to server
    fetch(`/api/activity/${selectedActivity.activity_id}/spo2`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            spo2_entries: validEntries
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update the selected activity with new SpO2 data (null if empty)
            selectedActivity.spo2_values = data.spo2_series || [];
            
            // Refresh the activity chart to show SpO2 data
            createActivityHeartRateChart(selectedActivity);
            
            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('spo2Modal'));
            modal.hide();
        } else {
            alert('Error saving SpO2 data: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error saving SpO2 data:', error);
        alert('Error saving SpO2 data');
    });
}

// TRIMP Editor Functions
let currentTrimpOverrides = {};
let currentDayData = null;

function openTrimpEditor() {
    if (!selectedDate) {
        console.error('No date selected for TRIMP editing');
        return;
    }
    
    // Load current day data and TRIMP overrides
    loadTrimpOverrides(selectedDate);
}

function loadTrimpOverrides(dateLabel) {
    // First, get the current day data to show calculated TRIMP values
    fetch(`/api/data/${dateLabel}`)
        .then(response => {
            if (response.ok) {
                return response.json();
            }
            return null;
        })
        .then(dayData => {
            currentDayData = dayData;
            
            // Then load existing TRIMP overrides
            return fetch(`/api/data/${dateLabel}/trimp-overrides`);
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                currentTrimpOverrides = data.trimp_overrides || {};
            } else {
                currentTrimpOverrides = {};
            }
            
            // Populate the modal
            populateTrimpOverridesForm();
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('trimpModal'));
            modal.show();
        })
        .catch(error => {
            console.error('Error loading TRIMP overrides:', error);
            currentDayData = null;
            currentTrimpOverrides = {};
            populateTrimpOverridesForm();
            
            const modal = new bootstrap.Modal(document.getElementById('trimpModal'));
            modal.show();
        });
}

function populateTrimpOverridesForm() {
    const container = document.getElementById('trimpOverridesForm');
    container.innerHTML = '';
    
    // Add column headers
    const headerDiv = document.createElement('div');
    headerDiv.className = 'row mb-2 fw-bold';
    headerDiv.innerHTML = `
        <div class="col-md-3">Zone</div>
        <div class="col-md-3">Calculated</div>
        <div class="col-md-6">Override</div>
    `;
    container.appendChild(headerDiv);
    
    // Create form for each zone (reverse order to match HR Zones section)
    zoneOrder.slice().reverse().forEach(zone => {
        const calculatedTrimp = currentDayData && currentDayData.presentation_buckets && 
                               currentDayData.presentation_buckets[zone] ? 
                               currentDayData.presentation_buckets[zone].trimp || 0 : 0;
        // Check if we have any overrides at all (binary system)
        const hasAnyOverrides = Object.keys(currentTrimpOverrides).length > 0;
        const overrideValue = currentTrimpOverrides[zone];
        
        // If we have overrides, use them (including 0), otherwise use calculated
        const displayValue = hasAnyOverrides ? (overrideValue !== undefined ? overrideValue : 0) : calculatedTrimp.toFixed(1);
        
        const zoneDiv = document.createElement('div');
        zoneDiv.className = 'row mb-3 align-items-center';
        zoneDiv.innerHTML = `
            <div class="col-md-3">
                <span class="badge" style="background-color: ${zoneColors[zone]}; color: white;">${zone}</span>
            </div>
            <div class="col-md-3">
                <small class="text-muted">${calculatedTrimp.toFixed(1)}</small>
            </div>
            <div class="col-md-6">
                <input type="number" class="form-control trimp-override-input" 
                       min="0" step="0.1"
                       value="${displayValue}"
                       data-zone="${zone}"
                       onchange="updateTrimpOverride('${zone}', this.value)">
            </div>
        `;
        container.appendChild(zoneDiv);
    });
    
    updateTotalTrimpOverride();
}

function updateTrimpOverride(zone, value) {
    if (value === '' || value === null || value === undefined) {
        currentTrimpOverrides[zone] = 0;
    } else {
        const numValue = parseFloat(value);
        if (!isNaN(numValue) && numValue >= 0) {
            currentTrimpOverrides[zone] = numValue;
        } else {
            currentTrimpOverrides[zone] = 0;
        }
    }
    
    // Ensure all zones are included in overrides (binary system)
    zoneOrder.forEach(zoneName => {
        if (!(zoneName in currentTrimpOverrides)) {
            // Get the current value from the form field
            const formField = document.querySelector(`input[data-zone="${zoneName}"]`);
            if (formField) {
                const fieldValue = parseFloat(formField.value) || 0;
                currentTrimpOverrides[zoneName] = fieldValue;
            } else {
                currentTrimpOverrides[zoneName] = 0;
            }
        }
    });
    
    updateTotalTrimpOverride();
}

function updateTotalTrimpOverride() {
    const total = Object.values(currentTrimpOverrides).reduce((sum, value) => sum + value, 0);
    document.getElementById('totalTrimpOverride').textContent = total.toFixed(1);
}

function clearTrimpOverrides() {
    if (!selectedDate) {
        console.error('No date selected for clearing TRIMP overrides');
        return;
    }
    
    // Delete overrides from server
    fetch(`/api/data/${selectedDate}/trimp-overrides`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            trimp_overrides: {}
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update the icon to show overrides are cleared
            updateTrimpIcon(false);
            
            // Refresh the two-week chart to show calculated values
            if (currentStartDate && currentEndDate) {
                loadTwoWeekData(currentStartDate, currentEndDate);
            }
            
            // Refresh the 14-week chart to show calculated values
            loadFourteenWeekData();
            
            // Refresh the single date view if it's open
            if (selectedDate) {
                loadDateData(selectedDate).then(dayData => {
                    showSingleDateView(selectedDate, dayData);
                });
            }
            
            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('trimpModal'));
            modal.hide();
        } else {
            alert('Error clearing TRIMP overrides: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error clearing TRIMP overrides:', error);
        alert('Error clearing TRIMP overrides');
    });
}

function saveTrimpOverrides() {
    if (!selectedDate) {
        console.error('No date selected for saving TRIMP overrides');
        return;
    }
    
    // Save exactly what's in the form fields (binary system)
    const completeOverrides = {};
    zoneOrder.forEach(zone => {
        completeOverrides[zone] = currentTrimpOverrides[zone] || 0;
    });
    
    // Send data to server
    fetch(`/api/data/${selectedDate}/trimp-overrides`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            trimp_overrides: completeOverrides
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update the icon to show overrides are active
            updateTrimpIcon(true);
            
            // Refresh the two-week chart to show overrides
            if (currentStartDate && currentEndDate) {
                loadTwoWeekData(currentStartDate, currentEndDate);
            }
            
            // Refresh the 14-week chart to show overrides
            loadFourteenWeekData();
            
            // Refresh the single date view if it's open
            if (selectedDate) {
                loadDateData(selectedDate).then(dayData => {
                    showSingleDateView(selectedDate, dayData);
                });
            }
            
            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('trimpModal'));
            modal.hide();
        } else {
            alert('Error saving TRIMP overrides: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error saving TRIMP overrides:', error);
        alert('Error saving TRIMP overrides');
    });
}

function updateTrimpIcon(hasOverrides) {
    const icon = document.getElementById('trimpIcon');
    // Always show the colored bars icon
    icon.innerHTML = createTrimpIcon();
}

function createTrimpIcon() {
    // Create an SVG icon with 9 colored bars representing the zones (vertical stacking)
    // Midnight blue (80-89) at bottom, hot red (160+) at top
    const barWidth = 12;
    const barHeight = 2;
    const totalHeight = barHeight * 9;
    
    return `<svg width="${barWidth}" height="${totalHeight}" viewBox="0 0 ${barWidth} ${totalHeight}">
        ${zoneOrder.slice().reverse().map((zone, index) => {
            const y = index * barHeight;
            return `<rect x="0" y="${y}" width="${barWidth}" height="${barHeight}" fill="${zoneColors[zone]}"/>`;
        }).join('')}
    </svg>`;
}

function checkTrimpOverrides(dateLabel) {
    fetch(`/api/data/${dateLabel}/trimp-overrides`)
        .then(response => response.json())
        .then(data => {
            const hasOverrides = data.success && data.trimp_overrides && Object.keys(data.trimp_overrides).length > 0;
            updateTrimpIcon(hasOverrides);
        })
        .catch(error => {
            console.error('Error checking TRIMP overrides:', error);
            updateTrimpIcon(false);
        });
}

// Manual Activity Functions
function openManualActivityModal() {
    if (!selectedDate) {
        alert('No date selected');
        return;
    }
    
    // Clear form fields
    document.getElementById('manualStartTime').value = '';
    document.getElementById('manualEndTime').value = '';
    document.getElementById('manualHeartRate').value = '';
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('manualActivityModal'));
    modal.show();
}

function createManualActivity() {
    if (!selectedDate) {
        alert('No date selected');
        return;
    }
    
    const startTime = document.getElementById('manualStartTime').value;
    const endTime = document.getElementById('manualEndTime').value;
    const heartRate = document.getElementById('manualHeartRate').value;
    
    // Validate inputs
    if (!startTime || !endTime || !heartRate) {
        alert('Please fill in all fields');
        return;
    }
    
    // Validate time format
    const timePattern = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!timePattern.test(startTime) || !timePattern.test(endTime)) {
        alert('Please use HH:MM format for times (e.g., 14:30)');
        return;
    }
    
    // Validate heart rate
    const hr = parseInt(heartRate);
    if (isNaN(hr) || hr < 0 || hr > 300) {
        alert('Heart rate must be a number between 0 and 300');
        return;
    }
    
    // Send request to create manual activity
    fetch(`/api/data/${selectedDate}/manual-activity`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            start_time: startTime,
            end_time: endTime,
            heart_rate: hr
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('manualActivityModal'));
            modal.hide();
            
            // Refresh the single date view to show the new activity
            loadDateData(selectedDate).then(dayData => {
                showSingleDateView(selectedDate, dayData);
            });
            
            // Refresh the two-week chart
            if (currentStartDate && currentEndDate) {
                loadTwoWeekData(currentStartDate, currentEndDate);
            }
            
            // Refresh the 14-week chart
            loadFourteenWeekData();
            
            alert('Manual activity created successfully!');
        } else {
            alert('Error creating manual activity: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error creating manual activity:', error);
        alert('Error creating manual activity');
    });
}

function deleteActivity(activityId) {
    if (!confirm('Are you sure you want to delete this activity?')) {
        return;
    }
    
    fetch(`/api/activity/${activityId}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Close the single activity view
            closeSingleActivityView();
            
            // Refresh the single date view
            if (selectedDate) {
                loadDateData(selectedDate).then(dayData => {
                    showSingleDateView(selectedDate, dayData);
                });
            }
            
            // Refresh the two-week chart
            if (currentStartDate && currentEndDate) {
                loadTwoWeekData(currentStartDate, currentEndDate);
            }
            
            // Refresh the 14-week chart
            loadFourteenWeekData();
            
            alert('Activity deleted successfully!');
        } else {
            alert('Error deleting activity: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error deleting activity:', error);
        alert('Error deleting activity');
    });
}

// CSV Upload Functions
function openCsvUploadEditor() {
    if (!selectedActivity) {
        console.error('No activity selected for CSV upload');
        return;
    }
    
    // Check current CSV override status
    checkCsvOverrideStatus();
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('csvUploadModal'));
    modal.show();
}

function checkCsvOverrideStatus() {
    if (!selectedActivity) return;
    
    fetch(`/api/activity/${selectedActivity.activity_id}/hr-csv-status`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                updateCsvIcon(data.has_csv_override);
                updateCsvStatus(data.has_csv_override);
            }
        })
        .catch(error => {
            console.error('Error checking CSV override status:', error);
            updateCsvIcon(false);
            updateCsvStatus(false);
        });
}

function updateCsvIcon(hasOverride) {
    const icon = document.getElementById('csvIcon');
    if (hasOverride) {
        icon.innerHTML = 'üì§ CSV*'; // Show override indicator
    } else {
        icon.innerHTML = 'üì§ CSV'; // Show default icon
    }
}

function updateCsvStatus(hasOverride) {
    const statusDiv = document.getElementById('csvStatus');
    if (hasOverride) {
        statusDiv.innerHTML = '<div class="alert alert-warning">This activity has uploaded CSV data that overrides the original HR data.</div>';
    } else {
        statusDiv.innerHTML = '<div class="alert alert-info">No CSV override is currently active for this activity.</div>';
    }
}

function uploadCsvData() {
    if (!selectedActivity) {
        console.error('No activity selected for CSV upload');
        return;
    }
    
    console.log('Starting CSV upload for activity:', selectedActivity.activity_id);
    
    const fileInput = document.getElementById('csvFile');
    const file = fileInput.files[0];
    
    if (!file) {
        alert('Please select a CSV file to upload');
        return;
    }
    
    console.log('File selected:', file.name, 'Size:', file.size, 'bytes');
    
    const formData = new FormData();
    formData.append('file', file);
    
    // Show loading state
    const uploadBtn = document.getElementById('uploadCsv');
    const originalText = uploadBtn.innerHTML;
    uploadBtn.innerHTML = 'Uploading...';
    uploadBtn.disabled = true;
    
    console.log('Sending request to:', `/api/activity/${selectedActivity.activity_id}/hr-csv-upload`);
    
    fetch(`/api/activity/${selectedActivity.activity_id}/hr-csv-upload`, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        console.log('Response status:', response.status);
        return response.json();
    })
    .then(data => {
        console.log('Response data:', data);
        
        if (data.success) {
            console.log('CSV upload successful');
            
            // Update icon and status
            updateCsvIcon(true);
            updateCsvStatus(true);
            
            // Refresh the activity view
            createActivityHeartRateChart(selectedActivity);
            
            // Refresh the single date view
            if (selectedDate) {
                loadDateData(selectedDate).then(dayData => {
                    showSingleDateView(selectedDate, dayData);
                });
            }
            
            // Refresh the two-week chart
            if (currentStartDate && currentEndDate) {
                loadTwoWeekData(currentStartDate, currentEndDate);
            }
            
            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('csvUploadModal'));
            modal.hide();
            
            // Clear the file input
            fileInput.value = '';
            
            alert('CSV uploaded successfully! Activity data has been updated.');
        } else {
            console.error('CSV upload failed:', data.error);
            alert('Error uploading CSV: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error uploading CSV:', error);
        alert('Error uploading CSV');
    })
    .finally(() => {
        // Restore button state
        uploadBtn.innerHTML = originalText;
        uploadBtn.disabled = false;
    });
}

function clearCsvOverride() {
    if (!selectedActivity) {
        console.error('No activity selected for clearing CSV override');
        return;
    }
    
    if (!confirm('Are you sure you want to clear the CSV override? This will restore the original HR data.')) {
        return;
    }
    
    // Show loading state
    const clearBtn = document.getElementById('clearCsvOverride');
    const originalText = clearBtn.innerHTML;
    clearBtn.innerHTML = 'Clearing...';
    clearBtn.disabled = true;
    
    fetch(`/api/activity/${selectedActivity.activity_id}/hr-csv-clear`, {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update icon and status
            updateCsvIcon(false);
            updateCsvStatus(false);
            
            // Refresh the activity view
            createActivityHeartRateChart(selectedActivity);
            
            // Refresh the single date view
            if (selectedDate) {
                loadDateData(selectedDate).then(dayData => {
                    showSingleDateView(selectedDate, dayData);
                });
            }
            
            // Refresh the two-week chart
            if (currentStartDate && currentEndDate) {
                loadTwoWeekData(currentStartDate, currentEndDate);
            }
            
            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('csvUploadModal'));
            modal.hide();
            
            alert('CSV override cleared successfully! Original HR data has been restored.');
        } else {
            alert('Error clearing CSV override: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error clearing CSV override:', error);
        alert('Error clearing CSV override');
    })
    .finally(() => {
        // Restore button state
        clearBtn.innerHTML = originalText;
        clearBtn.disabled = false;
    });
}

// Load activities for a specific date label
function loadActivitiesForDate(dateLabel) {
    fetch(`/api/activities/${dateLabel}`)
        .then(response => {
            if (!response.ok) {
                console.log(`No activities found for ${dateLabel}`);
                return [];
            }
            return response.json();
        })
        .then(activities => {
            console.log(`Activities for ${dateLabel}:`, activities);
            // Debug: Check if activities have raw_hr_data
            if (activities && activities.length > 0) {
                activities.forEach((activity, index) => {
                                    console.log(`Activity ${index} (${activity.activity_name}):`, {
                    has_heart_rate_values: !!activity.heart_rate_values,
                    heart_rate_values_type: typeof activity.heart_rate_values,
                    heart_rate_values_length: activity.heart_rate_values ? activity.heart_rate_values.length : 'N/A',
                    heart_rate_values_sample: activity.heart_rate_values ? activity.heart_rate_values.slice(0, 3) : 'N/A'
                });
                });
            }
            createActivitiesChart(activities);
        })
        .catch(error => {
            console.error(`Error loading activities for ${dateLabel}:`, error);
            createActivitiesChart([]);
        });
}

// Create horizontal bar chart for activities
function createActivitiesChart(activities) {
    const ctx = document.getElementById('activitiesChart').getContext('2d');
    const chartContainer = document.getElementById('activitiesChartContainer');
    
    // Destroy existing chart if it exists
    if (activitiesChart) {
        activitiesChart.destroy();
    }
    
    if (!activities || activities.length === 0) {
        // No activities - show empty chart with message
        chartContainer.style.height = '100px'; // Small height for empty state
        
        // Clear any existing overlay
        const existingOverlay = chartContainer.querySelector('.no-activities-overlay');
        if (existingOverlay) {
            existingOverlay.remove();
        }
        
        activitiesChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                scales: {
                    x: {
                        display: false
                    },
                    y: {
                        display: false
                    }
                }
            }
        });
        
        // Add a message overlay without destroying the canvas
        const overlay = document.createElement('div');
        overlay.className = 'no-activities-overlay d-flex align-items-center justify-content-center h-100';
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        overlay.innerHTML = '<p class="text-muted">No activities for this date</p>';
        chartContainer.appendChild(overlay);
        return;
    }
    
    // Clear any existing overlay
    const existingOverlay = chartContainer.querySelector('.no-activities-overlay');
    if (existingOverlay) {
        existingOverlay.remove();
    }
    
    // Calculate dynamic height based on number of activities
    // Each bar should be about 40px thick, plus some padding for labels and spacing
    const barHeight = 56;
    const padding = 40;
    const legendHeight = 50;
    const totalHeight = (activities.length * barHeight) + padding + legendHeight;
        
    // Update the container height
    chartContainer.style.height = totalHeight + 'px';
    
    // Prepare data for horizontal stacked bar chart
    const labels = activities.map(activity => {
        return activity.activity_name;
    });
    
    // Create datasets for each zone (horizontal bars)
    const datasets = zoneOrder.map(zone => {
        const data = activities.map(activity => {
            if (activity.presentation_buckets && activity.presentation_buckets[zone]) {
                return currentMetric === 'trimp' ? 
                    activity.presentation_buckets[zone].trimp : 
                    activity.presentation_buckets[zone].minutes;
            }
            return 0;
        });
        
        return {
            label: zone,
            data: data,
            backgroundColor: zoneColors[zone],
            borderColor: zoneColors[zone],
            borderWidth: 1,
            stack: 'activities'
        };
    });
    
    // Calculate x-axis maximum with minimum of 100
    let maxValue = 0;
    activities.forEach(activity => {
        if (activity.presentation_buckets) {
            let activityTotal = 0;
            Object.values(activity.presentation_buckets).forEach(bucket => {
                activityTotal += currentMetric === 'trimp' ? (bucket.trimp || 0) : (bucket.minutes || 0);
            });
            maxValue = Math.max(maxValue, activityTotal);
        }
    });
    
    // Ensure minimum x-axis maximum of 100
    const xAxisMax = Math.max(maxValue, 100);
    
    // Create the chart
    activitiesChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            indexAxis: 'y', // Horizontal bars
            responsive: true,
            maintainAspectRatio: false,
            onClick: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = activitiesChart.chartArea;
                if (!chartArea) return;
                
                // Check if click is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    
                    // Calculate which activity row was clicked based on y-coordinate
                    const yAxis = activitiesChart.scales.y;
                    const clickIndex = yAxis.getValueForPixel(y);
                    
                    if (clickIndex >= 0 && clickIndex < activities.length) {
                        const activity = activities[clickIndex];
                        showSingleActivityView(activity);
                    }
                }
            },
            onHover: function(event, elements) {
                const canvas = event.native.target;
                const rect = canvas.getBoundingClientRect();
                const x = event.native.x - rect.left;
                const y = event.native.y - rect.top;
                
                // Get the chart area
                const chartArea = activitiesChart.chartArea;
                if (!chartArea) {
                    event.native.target.style.cursor = 'default';
                    return;
                }
                
                // Check if hover is within the chart area (excluding axes)
                if (x >= chartArea.left && x <= chartArea.right && 
                    y >= chartArea.top && y <= chartArea.bottom) {
                    event.native.target.style.cursor = 'pointer';
                } else {
                    event.native.target.style.cursor = 'default';
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    mode: 'nearest',
                    intersect: false,
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const value = context.parsed.x;
                            const zone = context.dataset.label;
                            if (currentMetric === 'trimp') {
                                return `${zone}: ${value.toFixed(1)} TRIMP`;
                            } else {
                                return `${zone}: ${value.toFixed(0)} minutes`;
                            }
                        }
                    }
                },
                datalabels: {
                    display: false
                }
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: currentMetric === 'trimp' ? 'TRIMP' : 'Minutes'
                    },
                    max: xAxisMax
                },
                y: {
                    stacked: true
                }
            },
            elements: {
                bar: {
                    borderWidth: 1,
                    borderColor: '#ffffff'
                }
            }
        }
    });
}

// Create SpO2 chart for daily view
function createSpo2Chart(dateLabel, spo2Data, chartId, containerId) {
    const chartElement = document.getElementById(chartId);
    const containerElement = document.getElementById(containerId);
    
    if (!chartElement || !containerElement) {
        console.error('SpO2 chart elements not found');
        return;
    }
    
    // Destroy existing chart if it exists
    const existingChart = chartId === 'spo2Chart' ? spo2Chart : activitySpo2Chart;
    if (existingChart) {
        existingChart.destroy();
    }
    
    // Check if we have SpO2 data
    if (!spo2Data || spo2Data.length === 0) {
        containerElement.style.display = 'none';
        containerElement.style.height = '0px';
        return;
    }
    
    // Show container and set height
    containerElement.style.display = 'block';
    containerElement.style.height = '120px'; // Proportional to HR chart
    
    const ctx = chartElement.getContext('2d');
    
    // Get the date from the selected date label
    const chartDate = new Date(dateLabel + 'T00:00:00');
    
    // Create evenly spaced 24-hour timeline (every 1 minute for high resolution)
    const labels = [];
    for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 1) {
            const timestamp = new Date(chartDate);
            timestamp.setHours(hour, minute, 0, 0);
            labels.push(timestamp);
        }
    }
    
    // Process SpO2 data
    const chartLabels = [];
    const chartData = [];
    
    // Sort SpO2 data by timestamp
    const sortedSpo2Data = spo2Data.sort((a, b) => a.x.getTime() - b.x.getTime());
    
    // Add data points and insert null values for gaps > 5 minutes
    for (let i = 0; i < sortedSpo2Data.length; i++) {
        const currentPoint = sortedSpo2Data[i];
        
        // Add the current data point
        chartLabels.push(currentPoint.x);
        chartData.push(currentPoint.y);
        
        // Check if there's a gap to the next point
        if (i < sortedSpo2Data.length - 1) {
            const nextPoint = sortedSpo2Data[i + 1];
            const gapMinutes = (nextPoint.x.getTime() - currentPoint.x.getTime()) / (1000 * 60);
            
            // If gap is > 5 minutes, add a null point to create a visual break
            if (gapMinutes > 5) {
                // Add a null point 1 minute after the current segment
                const gapTimestamp = new Date(currentPoint.x.getTime() + (1 * 60 * 1000));
                chartLabels.push(gapTimestamp);
                chartData.push(null);
                
                // Add a null point 1 minute before the next segment
                const nextGapTimestamp = new Date(nextPoint.x.getTime() - (1 * 60 * 1000));
                chartLabels.push(nextGapTimestamp);
                chartData.push(null);
            }
        }
    }
    
    // Create the chart
    const newChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                // Background dataset with SpO2 color bands
                {
                    label: 'Background',
                    data: labels.map(label => ({ x: label, y: 100 })),
                    borderColor: 'transparent',
                    backgroundColor: function(context) {
                        const chart = context.chart;
                        const {ctx, chartArea} = chart;
                        
                        if (!chartArea) {
                            return 'transparent';
                        }
                        
                        // Create gradient for SpO2 zones
                        const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                        
                        // Add color stops for 8 equal SpO2 bands (top to bottom)
                        gradient.addColorStop(0, '#28a745');     // Band 1: Green (top)
                        gradient.addColorStop(0.25, '#28a745');  // Band 2: Green
                        gradient.addColorStop(0.25, '#9acd32');  // Band 3: Yellow-Green
                        gradient.addColorStop(0.375, '#9acd32'); // Band 4: Yellow
                        gradient.addColorStop(0.375, '#ffc107'); // Band 5: Orange
                        gradient.addColorStop(0.5, '#ffc107');   // Band 6: Red
                        gradient.addColorStop(0.5, '#fd7e14');   // Band 7: Hot Red
                        gradient.addColorStop(0.625, '#fd7e14'); // Band 8: Hot Red
                        gradient.addColorStop(0.625, '#e74c3c'); // Band 8: Hot Red
                        gradient.addColorStop(0.75, '#e74c3c');  // Band 8: Hot Red
                        gradient.addColorStop(0.75, '#dc3545');  // Band 8: Hot Red
                        gradient.addColorStop(1, '#dc3545');     // Band 8: Hot Red (bottom)
                        
                        return gradient;
                    },
                    borderWidth: 0,
                    fill: true,
                    tension: 0,
                    pointRadius: 0,
                    order: 100
                },
                // SpO2 line on top
                {
                    label: 'SpO2 (%)',
                    data: chartLabels.map((label, index) => ({ x: label, y: chartData[index] })),
                    borderColor: '#000080',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    pointHoverBackgroundColor: '#000080',
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            spanGaps: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    mode: 'nearest',
                    intersect: false,
                    callbacks: {
                        title: function(context) {
                            const rawData = context[0].raw;
                            if (rawData && rawData.x) {
                                const date = new Date(rawData.x);
                                const year = date.getFullYear();
                                const month = String(date.getMonth() + 1).padStart(2, '0');
                                const day = String(date.getDate()).padStart(2, '0');
                                const hour = String(date.getHours()).padStart(2, '0');
                                const minute = String(date.getMinutes()).padStart(2, '0');
                                return `Time: ${year}-${month}-${day} ${hour}:${minute}`;
                            }
                            return `Time: ${context[0].label}`;
                        },
                        label: function(context) {
                            if (context.dataset.label === 'SpO2 (%)') {
                                return `SpO2: ${context.parsed.y}%`;
                            }
                            return null;
                        }
                    }
                },
                datalabels: {
                    display: false
                }
            },
                            scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour',
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        display: true, // Show x-axis for gridlines
                        min: new Date(chartDate.getFullYear(), chartDate.getMonth(), chartDate.getDate(), 0, 0, 0),
                        max: new Date(chartDate.getFullYear(), chartDate.getMonth(), chartDate.getDate(), 23, 59, 0),
                        ticks: {
                            display: false, // Hide tick labels but keep gridlines
                            maxRotation: 0,
                            stepSize: 2,
                            source: 'auto'
                        },
                        grid: {
                            display: true,
                            color: 'rgba(0, 0, 0, 0.3)', // Same as HR chart
                            drawBorder: false,
                            z: 1 // Try to ensure gridlines are drawn above background
                        }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'SpO2 (%)'
                        },
                        min: 80,
                        max: 100,
                        ticks: {
                            stepSize: 5
                        }
                    }
                },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            }
        }
    });
    
    // Store the chart reference
    if (chartId === 'spo2Chart') {
        spo2Chart = newChart;
        // Force resize to match HR chart container
        setTimeout(() => {
            if (spo2Chart && hrChart) {
                // Copy the HR chart's width to ensure perfect alignment
                const hrContainer = document.querySelector('.chart-container canvas#hrChart').parentElement;
                const spo2Container = document.querySelector('.chart-container canvas#spo2Chart').parentElement;
                if (hrContainer && spo2Container) {
                    spo2Container.style.width = hrContainer.offsetWidth + 'px';
                    spo2Chart.resize();
                }
            }
        }, 100);
    } else {
        activitySpo2Chart = newChart;
        // Force resize to match HR chart container
        setTimeout(() => {
            if (activitySpo2Chart && activityHrChart) {
                // Copy the HR chart's width to ensure perfect alignment
                const hrContainer = document.querySelector('.chart-container canvas#activityHrChart').parentElement;
                const spo2Container = document.querySelector('.chart-container canvas#activitySpo2Chart').parentElement;
                if (hrContainer && spo2Container) {
                    spo2Container.style.width = hrContainer.offsetWidth + 'px';
                    activitySpo2Chart.resize();
                }
            }
        }, 100);
    }
}

// Create SpO2 chart for activity view
function createActivitySpo2Chart(activity, spo2Data, chartId, containerId) {
    const chartElement = document.getElementById(chartId);
    const containerElement = document.getElementById(containerId);
    
    if (!chartElement || !containerElement) {
        console.error('Activity SpO2 chart elements not found');
        return;
    }
    
    // Destroy existing chart if it exists
    if (activitySpo2Chart) {
        activitySpo2Chart.destroy();
    }
    
    // Check if we have SpO2 data
    if (!spo2Data || spo2Data.length === 0) {
        containerElement.style.display = 'none';
        containerElement.style.height = '0px';
        return;
    }
    
    // Show container and set height
    containerElement.style.display = 'block';
    containerElement.style.height = '120px'; // Proportional to HR chart
    
    const ctx = chartElement.getContext('2d');
    
    // Sort SpO2 data by timestamp
    const sortedSpo2Data = spo2Data.sort((a, b) => a.x.getTime() - b.x.getTime());
    
    // Get activity start and end times
    const startTime = sortedSpo2Data[0].x;
    const endTime = sortedSpo2Data[sortedSpo2Data.length - 1].x;
    
    // Create timeline based on activity duration
    const activityDurationMs = endTime.getTime() - startTime.getTime();
    const activityDurationMinutes = activityDurationMs / (1000 * 60);
    
    // Create evenly spaced timeline for the activity duration
    const labels = [];
    const stepMinutes = Math.max(1, Math.ceil(activityDurationMinutes / 1440)); // Max 1440 points (1 per minute for 24h)
    
    for (let i = 0; i <= activityDurationMinutes; i += stepMinutes) {
        const timestamp = new Date(startTime.getTime() + (i * 60 * 1000));
        labels.push(timestamp);
    }
    
    // Process SpO2 data
    const chartLabels = [];
    const chartData = [];
    
    // Add data points and insert null values for gaps > 5 minutes
    for (let i = 0; i < sortedSpo2Data.length; i++) {
        const currentPoint = sortedSpo2Data[i];
        
        // Add the current data point
        chartLabels.push(currentPoint.x);
        chartData.push(currentPoint.y);
        
        // Check if there's a gap to the next point
        if (i < sortedSpo2Data.length - 1) {
            const nextPoint = sortedSpo2Data[i + 1];
            const gapMinutes = (nextPoint.x.getTime() - currentPoint.x.getTime()) / (1000 * 60);
            
            // If gap is > 5 minutes, add a null point to create a visual break
            if (gapMinutes > 5) {
                // Add a null point 1 minute after the current segment
                const gapTimestamp = new Date(currentPoint.x.getTime() + (1 * 60 * 1000));
                chartLabels.push(gapTimestamp);
                chartData.push(null);
                
                // Add a null point 1 minute before the next segment
                const nextGapTimestamp = new Date(nextPoint.x.getTime() - (1 * 60 * 1000));
                chartLabels.push(nextGapTimestamp);
                chartData.push(null);
            }
        }
    }
    
    // Create the chart
    const newChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                // Background dataset with SpO2 color bands
                {
                    label: 'Background',
                    data: labels.map(label => ({ x: label, y: 100 })),
                    borderColor: 'transparent',
                    backgroundColor: function(context) {
                        const chart = context.chart;
                        const {ctx, chartArea} = chart;
                        
                        if (!chartArea) {
                            return 'transparent';
                        }
                        
                        // Create gradient for SpO2 zones
                        const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                        
                        // Add color stops for 8 equal SpO2 bands (top to bottom)
                        gradient.addColorStop(0, '#28a745');     // Band 1: Green (top)
                        gradient.addColorStop(0.25, '#28a745');  // Band 2: Green
                        gradient.addColorStop(0.25, '#9acd32');  // Band 3: Yellow-Green
                        gradient.addColorStop(0.375, '#9acd32'); // Band 4: Yellow
                        gradient.addColorStop(0.375, '#ffc107'); // Band 5: Orange
                        gradient.addColorStop(0.5, '#ffc107');   // Band 6: Red
                        gradient.addColorStop(0.5, '#fd7e14');   // Band 7: Hot Red
                        gradient.addColorStop(0.625, '#fd7e14'); // Band 8: Hot Red
                        gradient.addColorStop(0.625, '#e74c3c'); // Band 8: Hot Red
                        gradient.addColorStop(0.75, '#e74c3c');  // Band 8: Hot Red
                        gradient.addColorStop(0.75, '#dc3545');  // Band 8: Hot Red
                        gradient.addColorStop(1, '#dc3545');     // Band 8: Hot Red (bottom)
                        
                        return gradient;
                    },
                    borderWidth: 0,
                    fill: true,
                    tension: 0,
                    pointRadius: 0,
                    order: 100
                },
                // SpO2 line on top
                {
                    label: 'SpO2 (%)',
                    data: chartLabels.map((label, index) => ({ x: label, y: chartData[index] })),
                    borderColor: '#000080',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    pointHoverBackgroundColor: '#000080',
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            spanGaps: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    mode: 'nearest',
                    intersect: false,
                    callbacks: {
                        title: function(context) {
                            const rawData = context[0].raw;
                            if (rawData && rawData.x) {
                                const date = new Date(rawData.x);
                                const timeSinceStart = date.getTime() - startTime.getTime();
                                const totalMinutes = timeSinceStart / (1000 * 60);
                                
                                if (activityDurationMinutes <= 60) {
                                    // For activities <= 1 hour: use m:ss format
                                    const minutes = Math.floor(totalMinutes);
                                    const seconds = Math.floor((timeSinceStart % (1000 * 60)) / 1000);
                                    return `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                                } else {
                                    // For activities > 1 hour: use h:mm format
                                    const hours = Math.floor(totalMinutes / 60);
                                    const minutes = Math.floor(totalMinutes % 60);
                                    return `Time: ${hours}:${minutes.toString().padStart(2, '0')}`;
                                }
                            }
                            return `Time: ${context[0].label}`;
                        },
                        label: function(context) {
                            if (context.dataset.label === 'SpO2 (%)') {
                                return `SpO2: ${context.parsed.y}%`;
                            }
                            return null;
                        }
                    }
                },
                datalabels: {
                    display: false
                }
            },
                            scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: activityDurationMinutes <= 60 ? 'minute' : 'hour',
                            displayFormats: {
                                minute: 'mm:ss',
                                hour: 'HH:mm'
                            }
                        },
                        display: true, // Show x-axis for gridlines
                        min: startTime,
                        max: endTime,
                        ticks: {
                            display: false, // Hide tick labels but keep gridlines
                            maxRotation: 0,
                            stepSize: 2,
                            source: 'auto'
                        },
                        grid: {
                            display: true,
                            color: 'rgba(0, 0, 0, 0.3)', // Same as HR chart
                            drawBorder: false,
                            z: 1 // Try to ensure gridlines are drawn above background
                        }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'SpO2 (%)'
                        },
                        min: 80,
                        max: 100,
                        ticks: {
                            stepSize: 5
                        }
                    }
                },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            }
        }
    });
    
    // Store the chart reference
    activitySpo2Chart = newChart;
    // Force resize to match HR chart container
    setTimeout(() => {
        if (activitySpo2Chart && activityHrChart) {
            // Copy the HR chart's width to ensure perfect alignment
            const hrContainer = document.querySelector('.chart-container canvas#activityHrChart').parentElement;
            const spo2Container = document.querySelector('.chart-container canvas#activitySpo2Chart').parentElement;
            if (hrContainer && spo2Container) {
                spo2Container.style.width = hrContainer.offsetWidth + 'px';
                activitySpo2Chart.resize();
            }
        }
    }, 100);
}

// Create 24-hour heart rate chart
function createHeartRateChart(dateLabel, dayData) {
    
    const chartElement = document.getElementById('hrChart');
    if (!chartElement) {
        console.error('hrChart element not found');
        return;
    }
    
    const chartContainer = chartElement.parentElement;
    if (!chartContainer) {
        console.error('Chart container not found');
        return;
    }
    
    console.log('Chart element:', chartElement);
    console.log('Chart container:', chartContainer);
    console.log('Chart container dimensions:', chartContainer.offsetWidth, 'x', chartContainer.offsetHeight);
    console.log('Chart element dimensions:', chartElement.offsetWidth, 'x', chartElement.offsetHeight);
    
    const ctx = chartElement.getContext('2d');
    console.log('Chart context:', ctx);
    
    // Clean up any existing message overlay and restore canvas visibility
    const existingMessage = document.getElementById('hrChartMessage');
    if (existingMessage) {
        existingMessage.remove();
    }
    chartElement.style.display = 'block';
    
    // Destroy existing chart if it exists
    if (hrChart) {
        hrChart.destroy();
    }
    
    // Check if we have heart rate values
    if (!dayData.heart_rate_values || !Array.isArray(dayData.heart_rate_values) || dayData.heart_rate_values.length === 0) {
        // No raw data available - show message
        hrChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Heart Rate',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    borderWidth: 2,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                scales: {
                    x: {
                        display: false
                    },
                    y: {
                        display: false
                    }
                }
            }
        });
        
        // Hide the canvas and show a message overlay
        chartElement.style.display = 'none';
        const messageDiv = document.createElement('div');
        messageDiv.className = 'd-flex align-items-center justify-content-center h-100';
        messageDiv.innerHTML = '<p class="text-muted">No heart rate time-series data available</p>';
        messageDiv.id = 'hrChartMessage';
        chartContainer.appendChild(messageDiv);
        return;
    }
    
    // Process heart rate values
    const hrData = dayData.heart_rate_values;
    
    // Get the date from the selected date label
    const chartDate = new Date(dateLabel + 'T00:00:00');
    
    // Create evenly spaced 24-hour timeline (every 1 minute for high resolution)
    const labels = [];
    const data = [];
    
    for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 1) {
            const timestamp = new Date(chartDate);
            timestamp.setHours(hour, minute, 0, 0);
            labels.push(timestamp);
            data.push(null);
        }
    }
    
    // Sort data by timestamp
    const sortedData = hrData.sort((a, b) => {
        const timestampA = Array.isArray(a) ? a[0] : a.timestamp;
        const timestampB = Array.isArray(b) ? b[0] : b.timestamp;
        return timestampA - timestampB;
    });
    

    
    // Map heart rate data to the 24-hour timeline
    sortedData.forEach(point => {
        let timestamp, hr;
        
        if (Array.isArray(point)) {
            // Format: [timestamp, value]
            timestamp = point[0];
            hr = point[1];
        } else {
            // Format: {"value": x, "timestamp": y}
            timestamp = point.timestamp;
            hr = point.value;
        }
        
        // Skip null values
        if (hr === null || hr === undefined) return;
        
        // Convert timestamp to Date object
        const date = new Date(timestamp);
        
        // Find the exact index in our labels array (1-minute precision)
        const hour = date.getHours();
        const minute = date.getMinutes();
        
        // Create a timestamp for comparison (same date, specific hour/minute)
        const comparisonTimestamp = new Date(chartDate);
        comparisonTimestamp.setHours(hour, minute, 0, 0);
        
        const index = labels.findIndex(label => label.getTime() === comparisonTimestamp.getTime());
        if (index !== -1) {
            data[index] = hr;
        }
    });
    

    
    // Create a smart dataset that only includes null values for actual gaps
    const chartLabels = [];
    const chartData = [];
    
    // Sort the actual data points by timestamp
    const actualDataPoints = [];
    for (let i = 0; i < labels.length; i++) {
        if (data[i] !== null) {
            actualDataPoints.push({
                timestamp: labels[i],
                value: data[i]
            });
        }
    }
    
    // Add data points and insert null values for gaps > 5 minutes
    for (let i = 0; i < actualDataPoints.length; i++) {
        const currentPoint = actualDataPoints[i];
        
        // Add the current data point
        chartLabels.push(currentPoint.timestamp);
        chartData.push(currentPoint.value);
        
        // Check if there's a gap to the next point
        if (i < actualDataPoints.length - 1) {
            const nextPoint = actualDataPoints[i + 1];
            const gapMinutes = (nextPoint.timestamp.getTime() - currentPoint.timestamp.getTime()) / (1000 * 60);
            
            // If gap is > 5 minutes, add a null point to create a visual break
            if (gapMinutes > 5) {
                // Add a null point 1 minute after the current segment
                const gapTimestamp = new Date(currentPoint.timestamp.getTime() + (1 * 60 * 1000)); // 1 minute after current
                chartLabels.push(gapTimestamp);
                chartData.push(null);
                
                // Add a null point 1 minute before the next segment
                const nextGapTimestamp = new Date(nextPoint.timestamp.getTime() - (1 * 60 * 1000)); // 1 minute before next
                chartLabels.push(nextGapTimestamp);
                chartData.push(null);
            }
        }
    }
    
    // Process SpO2 data if available
    const spo2Data = [];
    if (dayData.spo2_values && Array.isArray(dayData.spo2_values) && dayData.spo2_values.length > 0) {
        dayData.spo2_values.forEach(spo2Point => {
            const timestamp = new Date(spo2Point[0]);
            const spo2Value = spo2Point[1];
            
            // Only include SpO2 data for this day
            if (timestamp.getDate() === chartDate.getDate() && 
                timestamp.getMonth() === chartDate.getMonth() && 
                timestamp.getFullYear() === chartDate.getFullYear()) {
                spo2Data.push({
                    x: timestamp,
                    y: spo2Value
                });
            }
        });
    }
    
    // Create SpO2 chart if data exists
    createSpo2Chart(dateLabel, spo2Data, 'spo2Chart', 'spo2ChartContainer');
    
    // Small delay to ensure DOM is ready
    setTimeout(() => {
        // Create datasets array (HR only - SpO2 is in separate chart)
        const datasets = [
            // Single background dataset with gradient
            {
                label: 'Background',
                data: labels.map(label => ({ x: label, y: 160 })), // Full height background for 24-hour timeline
                borderColor: 'transparent',
                backgroundColor: function(context) {
                    const chart = context.chart;
                    const {ctx, chartArea} = chart;
                    
                    if (!chartArea) {
                        return 'transparent';
                    }
                    
                    // Create gradient
                    const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                    
                    // Add color stops for each zone
                    gradient.addColorStop(0, '#e74c3c'); // 160+ Red
                    gradient.addColorStop(1/12, '#e74c3c'); // 150-159 Red
                    gradient.addColorStop(1/12, '#fd7e14'); // 150-159 Orange
                    gradient.addColorStop(1/6, '#fd7e14'); // 140-149 Orange
                    gradient.addColorStop(1/6, '#ffc107'); // 140-149 Yellow
                    gradient.addColorStop(3/12, '#ffc107'); // 130-139 Yellow
                    gradient.addColorStop(3/12, '#9acd32'); // 130-139 Yellow-green
                    gradient.addColorStop(1/3, '#9acd32'); // 120-129 Yellow-green
                    gradient.addColorStop(1/3, '#28a745'); // 120-129 Green
                    gradient.addColorStop(5/12, '#28a745'); // 110-119 Green
                    gradient.addColorStop(5/12, '#006d5b'); // 110-119 Deep teal
                    gradient.addColorStop(1/2, '#006d5b'); // 100-109 Deep teal
                    gradient.addColorStop(1/2, '#004080'); // 100-109 Night sky blue
                    gradient.addColorStop(7/12, '#004080'); // 90-99 Night sky blue
                    gradient.addColorStop(7/12, '#002040'); // 80-89 Midnight
                    gradient.addColorStop(2/3, '#002040'); // 80-89 Midnight
                    gradient.addColorStop(2/3, '#000000'); // 80-89 Black
                    gradient.addColorStop(1, '#000000'); // Below 80 Black
                    
                    return gradient;
                },
                borderWidth: 0,
                fill: true,
                tension: 0,
                pointRadius: 0,
                order: 100 // Draw background first
            },
            // Heart rate line on top
            {
                label: 'Heart Rate (BPM)',
                data: chartLabels.map((label, index) => ({ x: label, y: chartData[index] })), // Use data with null values for gaps
                borderColor: '#e74c3c',
                backgroundColor: 'transparent',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: '#e74c3c',
                order: 0
            }
        ];
        
        // Create the chart
        hrChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels, // Use full 24-hour timeline for consistent x-axis
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                spanGaps: false, // Don't draw lines across gaps
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'nearest',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                // Get the raw timestamp from the data point
                                const rawData = context[0].raw;
                                if (rawData && rawData.x) {
                                    const date = new Date(rawData.x);
                                    const year = date.getFullYear();
                                    const month = String(date.getMonth() + 1).padStart(2, '0');
                                    const day = String(date.getDate()).padStart(2, '0');
                                    const hour = String(date.getHours()).padStart(2, '0');
                                    const minute = String(date.getMinutes()).padStart(2, '0');
                                    return `Time: ${year}-${month}-${day} ${hour}:${minute}`;
                                }
                                // Fallback to the label if raw data not available
                                return `Time: ${context[0].label}`;
                            },
                            label: function(context) {
                                // Show tooltip for heart rate and SpO2 data
                                if (context.dataset.label === 'Heart Rate (BPM)') {
                                    return `Heart Rate: ${context.parsed.y} BPM`;
                                } else if (context.dataset.label === 'SpO2 (%)') {
                                    return `SpO2: ${context.parsed.y}%`;
                                }
                                return null; // Hide background dataset from tooltip
                            }
                        }
                    },
                    datalabels: {
                        display: false,
                        formatter: function() {
                            return ''; // Return empty string to ensure no labels
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour',
                            displayFormats: {
                                hour: 'HH:mm'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        min: new Date(chartDate.getFullYear(), chartDate.getMonth(), chartDate.getDate(), 0, 0, 0),
                        max: new Date(chartDate.getFullYear(), chartDate.getMonth(), chartDate.getDate(), 23, 59, 0),
                        ticks: {
                            maxRotation: 0,
                            stepSize: 2,
                            source: 'auto'
                        },
                        grid: {
                            display: true,
                            color: 'rgba(0, 0, 0, 0.3)', // Same as activity chart
                            drawBorder: false,
                            z: 1 // Try to ensure gridlines are drawn above background
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Heart Rate (BPM)'
                        },
                        min: 40,
                        max: 160,
                        ticks: {
                            stepSize: 20
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });
        
        
    }, 100);
}

// Create activity heart rate chart
function createActivityHeartRateChart(activity) {
    console.log('Creating activity heart rate chart for activity:', activity);
    
    // Ensure the single activity section is visible
    const singleActivitySection = document.getElementById('singleActivitySection');
    if (!singleActivitySection || singleActivitySection.style.display === 'none') {
        console.error('Single activity section is not visible');
        return;
    }
    
    // Ensure we have clean canvas elements
    const chartContainer = document.querySelector('#singleActivitySection .chart-container');
    const spo2ChartContainer = document.getElementById('activitySpo2ChartContainer');
    
    if (!chartContainer) {
        console.error('Activity chart container not found');
        return;
    }
    
    if (!spo2ChartContainer) {
        console.error('Activity SpO2 chart container not found');
        return;
    }
    
    // Clear the containers and recreate the canvases
    chartContainer.innerHTML = '<canvas id="activityHrChart"></canvas>';
    spo2ChartContainer.innerHTML = '<canvas id="activitySpo2Chart"></canvas>';
    
    const chartElement = document.getElementById('activityHrChart');
    if (!chartElement) {
        console.error('Activity chart element not found after recreation');
        return;
    }
    
    console.log('Activity chart element:', chartElement);
    console.log('Activity chart container:', chartContainer);
    
    const ctx = chartElement.getContext('2d');
    if (!ctx) {
        console.error('Could not get 2D context for activity chart');
        return;
    }
    console.log('Activity chart context:', ctx);
    
    // Destroy existing chart if it exists
    if (activityHrChart) {
        activityHrChart.destroy();
        activityHrChart = null;
    }
    if (activitySpo2Chart) {
        activitySpo2Chart.destroy();
        activitySpo2Chart = null;
    }
    
    // Check if we have heart rate values for this activity
    if (!activity.heart_rate_values || !Array.isArray(activity.heart_rate_values) || activity.heart_rate_values.length === 0) {
        console.log('No heart rate values available for activity');
        console.log('Activity data keys:', Object.keys(activity));
        console.log('heart_rate_values value:', activity.heart_rate_values);
        console.log('heart_rate_values type:', typeof activity.heart_rate_values);
        console.log('heart_rate_values length:', activity.heart_rate_values ? activity.heart_rate_values.length : 'N/A');
        console.log('Full activity data:', activity);
        
        // Wait for DOM to be ready before creating chart
        setTimeout(() => {
            // No raw data available - show message
            activityHrChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Heart Rate',
                        data: [],
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        borderWidth: 2,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    }
                }
            });
            
            // Add a message overlay
            chartContainer.innerHTML = '<div class="d-flex align-items-center justify-content-center h-100"><p class="text-muted">No heart rate time-series data available for this activity</p></div>';
            spo2ChartContainer.innerHTML = '<canvas id="activitySpo2Chart"></canvas>';
        }, 100);
        return;
    }
    
    // Process heart rate values
    const hrData = activity.heart_rate_values;
    const breathingData = activity.breathing_rate_values || [];
    console.log('Activity heart rate values length:', hrData.length);
    
    // Process SpO2 data if available
    const spo2Data = [];
    if (activity.spo2_values && activity.spo2_values.length > 0) {
        console.log('Processing SpO2 data for activity:', activity.spo2_values.length, 'points');
        activity.spo2_values.forEach(spo2Point => {
            spo2Data.push({
                x: new Date(spo2Point[0]),
                y: spo2Point[1]
            });
        });
    }
    
    // Create SpO2 chart if data exists
    createActivitySpo2Chart(activity, spo2Data, 'activitySpo2Chart', 'activitySpo2ChartContainer');
    console.log('Activity breathing rate values length:', breathingData.length);
    console.log('First few HR data points:', hrData.slice(0, 5));
    console.log('First few breathing data points:', breathingData.slice(0, 5));
    
    // Sort data by timestamp
    const sortedData = hrData.sort((a, b) => {
        const timestampA = Array.isArray(a) ? a[0] : a.timestamp;
        const timestampB = Array.isArray(b) ? b[0] : b.timestamp;
        return timestampA - timestampB;
    });
    
    // Sort breathing data by timestamp if available
    const sortedBreathingData = breathingData.length > 0 ? breathingData.sort((a, b) => {
        const timestampA = Array.isArray(a) ? a[0] : a.timestamp;
        const timestampB = Array.isArray(b) ? b[0] : b.timestamp;
        return timestampA - timestampB;
    }) : [];
    
    console.log('Sorted activity data length:', sortedData.length);
    
    // Extract timestamps and heart rate values
    const timestamps = [];
    const hrValues = [];
    const breathingValues = [];
    
    sortedData.forEach(point => {
        let timestamp, hr;
        
        if (Array.isArray(point)) {
            // Format: [timestamp, value]
            timestamp = point[0];
            hr = point[1];
        } else {
            // Format: {"value": x, "timestamp": y}
            timestamp = point.timestamp;
            hr = point.value;
        }
        
        // Skip null values
        if (hr === null || hr === undefined) return;
        
        timestamps.push(new Date(timestamp));
        hrValues.push(hr);
    });
    
    // Extract breathing rate values if available
    if (sortedBreathingData.length > 0) {
        sortedBreathingData.forEach(point => {
            let timestamp, breathing;
            
            if (Array.isArray(point)) {
                // Format: [timestamp, value]
                timestamp = point[0];
                breathing = point[1];
            } else {
                // Format: {"value": x, "timestamp": y}
                timestamp = point.timestamp;
                breathing = point.value;
            }
            
            // Skip null values
            if (breathing === null || breathing === undefined) return;
            
            breathingValues.push({ timestamp: new Date(timestamp), value: breathing });
        });
    }
    
    console.log('Processed activity timestamps length:', timestamps.length);
    console.log('Processed activity HR values length:', hrValues.length);
    console.log('First few timestamps:', timestamps.slice(0, 5));
    console.log('First few HR values:', hrValues.slice(0, 5));
    
    // Create a smart dataset that only includes null values for actual gaps
    const chartLabels = [];
    const chartData = [];
    
    // Add data points and insert null values for gaps > 5 minutes
    for (let i = 0; i < timestamps.length; i++) {
        const currentPoint = timestamps[i];
        const currentHR = hrValues[i];
        
        // Add the current data point
        chartLabels.push(currentPoint);
        chartData.push(currentHR);
        
        // Check if there's a gap to the next point
        if (i < timestamps.length - 1) {
            const nextPoint = timestamps[i + 1];
            const gapMinutes = (nextPoint.getTime() - currentPoint.getTime()) / (1000 * 60);
            
            // If gap is > 5 minutes, add a null point to create a visual break
            if (gapMinutes > 5) {
                // Add a null point 1 minute after the current segment
                const gapTimestamp = new Date(currentPoint.getTime() + (1 * 60 * 1000)); // 1 minute after current
                chartLabels.push(gapTimestamp);
                chartData.push(null);
                
                // Add a null point 1 minute before the next segment
                const nextGapTimestamp = new Date(nextPoint.getTime() - (1 * 60 * 1000)); // 1 minute before next
                chartLabels.push(nextGapTimestamp);
                chartData.push(null);
            }
        }
    }
    
    console.log('Chart labels length:', chartLabels.length);
    console.log('Chart data length:', chartData.length);
    console.log('First few chart labels:', chartLabels.slice(0, 5));
    console.log('First few chart data points:', chartData.slice(0, 5));
    
    // Get the start and end times for the activity
    const startTime = chartLabels[0];
    const endTime = chartLabels[chartLabels.length - 1];
    
    console.log('Activity start time:', startTime);
    console.log('Activity end time:', endTime);
    
    // Calculate activity duration and determine smart tick intervals
    const activityDurationMs = endTime.getTime() - startTime.getTime();
    const activityDurationMinutes = activityDurationMs / (1000 * 60);
    
    // Define possible tick intervals in minutes
    const possibleIntervals = [0.5, 1, 5, 15, 30, 60, 120, 300, 600]; // 30s, 1m, 5m, 15m, 30m, 1h, 2h, 5h, 10h
    
    // Find the optimal interval that gives us ‚â§ 23 ticks
    let optimalInterval = 1; // Default to 1 minute
    for (let i = 0; i < possibleIntervals.length; i++) {
        const interval = possibleIntervals[i];
        const numTicks = Math.ceil(activityDurationMinutes / interval) + 1; // +1 for the start tick
        if (numTicks <= 23) {
            optimalInterval = interval;
            break;
        }
    }
    
    // Generate custom tick positions at round intervals from start
    const customTicks = [];
    let currentTime = 0; // Start at 0 minutes
    while (currentTime <= activityDurationMinutes) {
        customTicks.push(new Date(startTime.getTime() + (currentTime * 60 * 1000)));
        currentTime += optimalInterval;
    }
    
    console.log('Activity duration:', activityDurationMinutes.toFixed(1), 'minutes');
    console.log('Using tick interval:', optimalInterval, 'minutes');
    console.log('Number of ticks:', customTicks.length);
    // Helper function to format time based on interval
    function formatTickLabel(timestamp) {
        const timeSinceStart = timestamp.getTime() - startTime.getTime();
        const totalMinutes = timeSinceStart / (1000 * 60);
        
        if (optimalInterval <= 1) {
            // For 30s and 1m intervals: use m:ss format
            const minutes = Math.floor(totalMinutes);
            const seconds = Math.floor((timeSinceStart % (1000 * 60)) / 1000);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        } else {
            // For 5m and larger intervals: use h:mm format
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.floor(totalMinutes % 60);
            return `${hours}:${minutes.toString().padStart(2, '0')}`;
        }
    }
    
    console.log('Custom tick positions:', customTicks.map(t => formatTickLabel(t)));
    
    // Small delay to ensure DOM is ready and chart element is properly set up
    setTimeout(() => {
        // Re-get the chart element and context after the delay to ensure they're still valid
        const chartElement = document.getElementById('activityHrChart');
        if (!chartElement) {
            console.error('Activity chart element not found after delay');
            return;
        }
        
        const ctx = chartElement.getContext('2d');
        if (!ctx) {
            console.error('Could not get 2D context for activity chart after delay');
            return;
        }
        
        // Create datasets array
        const datasets = [
            // Single background dataset with gradient
            {
                label: 'Background',
                data: chartLabels.map(timestamp => ({ x: timestamp, y: 160 })), // Full height background
                borderColor: 'transparent',
                backgroundColor: function(context) {
                    const chart = context.chart;
                    const {ctx, chartArea} = chart;
                    
                    if (!chartArea) {
                        return 'transparent';
                    }
                    
                    // Create gradient
                    const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                    
                                         // Add color stops for each zone
                     gradient.addColorStop(0, '#e74c3c'); // 160+ Red
                     gradient.addColorStop(1/12, '#e74c3c'); // 150-159 Red
                     gradient.addColorStop(1/12, '#fd7e14'); // 150-159 Orange
                     gradient.addColorStop(1/6, '#fd7e14'); // 140-149 Orange
                     gradient.addColorStop(1/6, '#ffc107'); // 140-149 Yellow
                     gradient.addColorStop(3/12, '#ffc107'); // 130-139 Yellow
                     gradient.addColorStop(3/12, '#9acd32'); // 130-139 Yellow-green
                     gradient.addColorStop(1/3, '#9acd32'); // 120-129 Yellow-green
                     gradient.addColorStop(1/3, '#28a745'); // 120-129 Green
                     gradient.addColorStop(5/12, '#28a745'); // 110-119 Green
                     gradient.addColorStop(5/12, '#006d5b'); // 110-119 Deep teal
                     gradient.addColorStop(1/2, '#006d5b'); // 100-109 Deep teal
                     gradient.addColorStop(1/2, '#004080'); // 100-109 Night sky blue
                     gradient.addColorStop(7/12, '#004080'); // 90-99 Night sky blue
                     gradient.addColorStop(7/12, '#002040'); // 80-89 Midnight
                     gradient.addColorStop(2/3, '#002040'); // 80-89 Midnight
                     gradient.addColorStop(2/3, '#000000'); // 80-89 Black
                     gradient.addColorStop(1, '#000000'); // Below 80 Black
                     
                     return gradient;
                 },
                 borderWidth: 0,
                 fill: true,
                 tension: 0,
                 pointRadius: 0,
                 order: 2
             },
             // Heart rate line on top
             {
                 label: 'Heart Rate (BPM)',
                 data: chartLabels.map((timestamp, index) => ({ x: timestamp, y: chartData[index] })),
                 borderColor: '#e74c3c',
                 backgroundColor: 'transparent',
                 borderWidth: 2,
                 fill: false,
                 tension: 0.1,
                 pointRadius: 0,
                 pointHoverRadius: 4,
                 pointHoverBackgroundColor: '#e74c3c',
                 order: 0,
                 yAxisID: 'y'
             }
        ];
        
        // Add breathing rate dataset if available
        if (breathingValues.length > 0) {
            // Create breathing rate data points aligned with HR timestamps
            const breathingDataPoints = chartLabels.map(timestamp => {
                // Find the closest breathing rate value to this timestamp
                const closestBreathing = breathingValues.find(bv => 
                    Math.abs(bv.timestamp.getTime() - timestamp.getTime()) < 30000 // Within 30 seconds
                );
                return { x: timestamp, y: closestBreathing ? closestBreathing.value : null };
            });
            
            datasets.push({
                                        label: 'Breathing Rate (BRPM)',
                data: breathingDataPoints,
                borderColor: '#87CEEB', // Light blue
                backgroundColor: 'transparent',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 4,
                pointHoverBackgroundColor: '#87CEEB',
                order: 1,
                yAxisID: 'y1' // Secondary y-axis
            });
        }
        
        // SpO2 is now in separate chart
        console.log('SpO2 data available for activity:', activity.spo2_values ? activity.spo2_values.length : 0, 'points');
        
        // Create the chart
        activityHrChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: chartLabels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                spanGaps: false, // Don't draw lines across gaps
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'nearest',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                // Get the raw timestamp from the data point
                                const rawData = context[0].raw;
                                if (rawData && rawData.x) {
                                    const timestamp = new Date(rawData.x);
                                    const timeSinceStart = timestamp.getTime() - startTime.getTime();
                                    const totalMinutes = timeSinceStart / (1000 * 60);
                                    
                                    if (optimalInterval <= 1) {
                                        // For 30s and 1m intervals: use m:ss format
                                        const minutes = Math.floor(totalMinutes);
                                        const seconds = Math.floor((timeSinceStart % (1000 * 60)) / 1000);
                                        return `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                                    } else {
                                        // For 5m and larger intervals: use h:mm format
                                        const hours = Math.floor(totalMinutes / 60);
                                        const minutes = Math.floor(totalMinutes % 60);
                                        return `Time: ${hours}:${minutes.toString().padStart(2, '0')}`;
                                    }
                                }
                                // Fallback to the label if raw data not available
                                return `Time: ${context[0].label}`;
                            },
                            label: function(context) {
                                // Show tooltip for heart rate and breathing rate data
                                if (context.dataset.label === 'Heart Rate (BPM)') {
                                    return `Heart Rate: ${context.parsed.y} BPM`;
                                } else if (context.dataset.label === 'Breathing Rate (BRPM)') {
                                    return `Breathing Rate: ${context.parsed.y.toFixed(1)} BRPM`;
                                }
                                return null; // Hide background dataset from tooltip
                            }
                        }
                    },
                    datalabels: {
                        display: false,
                        formatter: function() {
                            return ''; // Return empty string to ensure no labels
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            displayFormats: {
                                minute: 'mm:ss',
                                second: 'mm:ss'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Time Since Activity Start'
                        },
                        min: startTime,
                        max: endTime,
                        ticks: {
                            maxRotation: 0,
                            source: 'auto',
                            callback: function(value, index, values) {
                                // Calculate time since activity start
                                const timestamp = new Date(value);
                                const timeSinceStart = timestamp.getTime() - startTime.getTime();
                                const totalMinutes = timeSinceStart / (1000 * 60);
                                
                                if (optimalInterval <= 1) {
                                    // For 30s and 1m intervals: use m:ss format
                                    const minutes = Math.floor(totalMinutes);
                                    const seconds = Math.floor((timeSinceStart % (1000 * 60)) / 1000);
                                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                                } else {
                                    // For 5m and larger intervals: use h:mm format
                                    const hours = Math.floor(totalMinutes / 60);
                                    const minutes = Math.floor(totalMinutes % 60);
                                    return `${hours}:${minutes.toString().padStart(2, '0')}`;
                                }
                            }
                        },
                        afterBuildTicks: function(axis) {
                            // Replace the ticks with our custom ones at optimal intervals
                            const newTicks = [];
                            let currentTime = 0;
                            while (currentTime <= activityDurationMinutes) {
                                const tickTime = new Date(startTime.getTime() + (currentTime * 60 * 1000));
                                newTicks.push({
                                    value: tickTime.getTime(),
                                    label: (() => {
                                        const timeSinceStart = tickTime.getTime() - startTime.getTime();
                                        const totalMinutes = timeSinceStart / (1000 * 60);
                                        
                                        if (optimalInterval <= 1) {
                                            const minutes = Math.floor(totalMinutes);
                                            const seconds = Math.floor((timeSinceStart % (1000 * 60)) / 1000);
                                            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                                        } else {
                                            const hours = Math.floor(totalMinutes / 60);
                                            const minutes = Math.floor(totalMinutes % 60);
                                            return `${hours}:${minutes.toString().padStart(2, '0')}`;
                                        }
                                    })()
                                });
                                currentTime += optimalInterval;
                            }
                            axis.ticks = newTicks;
                        },
                        time: {
                            unit: 'minute',
                            displayFormats: {
                                minute: 'mm:ss',
                                second: 'mm:ss'
                            }
                        },
                        grid: {
                            display: true,
                            color: 'rgba(0, 0, 0, 0.3)', // Even darker for visibility
                            drawBorder: false,
                            z: 1 // Try to ensure gridlines are drawn above background
                        }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Heart Rate (BPM)'
                        },
                        min: 40,
                        max: 160,
                        ticks: {
                            stepSize: 20
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: breathingValues.length > 0, // Show only if breathing data exists
                        position: 'right',
                        title: {
                            display: breathingValues.length > 0, // Show title only if breathing data exists
                            text: 'Breathing Rate (BRPM)'
                        },
                        min: 0,
                        max: 60, // Typical breathing rate range
                        ticks: {
                            stepSize: 10
                        },
                        grid: {
                            drawOnChartArea: false, // Only want to show grid for primary axis
                        },
                    },

                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });
        
        console.log('Activity chart created successfully:', activityHrChart);
        console.log('Activity chart dimensions after creation:', chartElement.offsetWidth, 'x', chartElement.offsetHeight);
    }, 100);
}

// Notes Functions
function loadDailyNotes(dateLabel) {
    fetch(`/api/data/${dateLabel}/notes`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const notesElement = document.getElementById('dailyNotes');
                if (notesElement) {
                    if (data.notes && data.notes.trim()) {
                        notesElement.innerHTML = `<p class="mb-0">${data.notes.replace(/\n/g, '<br>')}</p>`;
                    } else {
                        notesElement.innerHTML = '<p class="mb-0"></p>';
                    }
                }
            } else {
                console.error('Error loading daily notes:', data.error);
                const notesElement = document.getElementById('dailyNotes');
                if (notesElement) {
                    notesElement.innerHTML = '<p class="text-danger mb-0">Error loading notes</p>';
                }
            }
        })
        .catch(error => {
            console.error('Error loading daily notes:', error);
            const notesElement = document.getElementById('dailyNotes');
            if (notesElement) {
                notesElement.innerHTML = '<p class="text-danger mb-0">Error loading notes</p>';
            }
        });
}

function editDailyNotes(dateLabel) {
    const notesElement = document.getElementById('dailyNotes');
    const currentNotesElement = notesElement.querySelector('p');
    let currentNotes = '';
    
    if (currentNotesElement) {
        // Convert <br> tags back to newlines for the textarea
        currentNotes = currentNotesElement.innerHTML.replace(/<br\s*\/?>/gi, '\n');
    }
    
    // Create edit form
    notesElement.innerHTML = `
        <textarea class="form-control" rows="4" onclick="event.stopPropagation()">${currentNotes}</textarea>
        <div class="mt-2">
            <button type="button" class="btn btn-sm btn-primary" onclick="event.stopPropagation(); saveDailyNotes('${dateLabel}')">Save</button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="event.stopPropagation(); cancelDailyNotes('${dateLabel}')">Cancel</button>
        </div>
    `;
    // Focus and move cursor to end
    const textarea = notesElement.querySelector('textarea');
    if (textarea) {
        textarea.focus();
        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }
}

function saveDailyNotes(dateLabel) {
    const notesElement = document.getElementById('dailyNotes');
    const textarea = notesElement.querySelector('textarea');
    const notes = textarea.value;
    
    fetch(`/api/data/${dateLabel}/notes`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ notes: notes })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            if (notes && notes.trim()) {
                notesElement.innerHTML = `<p class="mb-0">${notes.replace(/\n/g, '<br>')}</p>`;
            } else {
                notesElement.innerHTML = '<p class="mb-0"></p>';
            }
        } else {
            console.error('Error saving daily notes:', data.error);
            alert('Error saving notes: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error saving daily notes:', error);
        alert('Error saving notes');
    });
}

function cancelDailyNotes(dateLabel) {
    loadDailyNotes(dateLabel);
}

function loadActivityNotes(activityId) {
    fetch(`/api/activity/${activityId}/notes`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const notesElement = document.getElementById('activityNotes');
                if (notesElement) {
                    if (data.notes && data.notes.trim()) {
                        notesElement.innerHTML = `<p class="mb-0">${data.notes.replace(/\n/g, '<br>')}</p>`;
                    } else {
                        notesElement.innerHTML = '<p class="mb-0"></p>';
                    }
                }
            } else {
                console.error('Error loading activity notes:', data.error);
                const notesElement = document.getElementById('activityNotes');
                if (notesElement) {
                    notesElement.innerHTML = '<p class="text-danger mb-0">Error loading notes</p>';
                }
            }
        })
        .catch(error => {
            console.error('Error loading activity notes:', error);
            const notesElement = document.getElementById('activityNotes');
            if (notesElement) {
                notesElement.innerHTML = '<p class="text-danger mb-0">Error loading notes</p>';
            }
        });
}

function editActivityNotes(activityId) {
    const notesElement = document.getElementById('activityNotes');
    const currentNotesElement = notesElement.querySelector('p');
    let currentNotes = '';
    
    if (currentNotesElement) {
        // Convert <br> tags back to newlines for the textarea
        currentNotes = currentNotesElement.innerHTML.replace(/<br\s*\/?>/gi, '\n');
    }
    
    // Create edit form
    notesElement.innerHTML = `
        <textarea class="form-control" rows="4" onclick="event.stopPropagation()">${currentNotes}</textarea>
        <div class="mt-2">
            <button type="button" class="btn btn-sm btn-primary" onclick="event.stopPropagation(); saveActivityNotes('${activityId}')">Save</button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="event.stopPropagation(); cancelActivityNotes('${activityId}')">Cancel</button>
        </div>
    `;
    // Focus and move cursor to end
    const textarea = notesElement.querySelector('textarea');
    if (textarea) {
        textarea.focus();
        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }
}

function saveActivityNotes(activityId) {
    const notesElement = document.getElementById('activityNotes');
    const textarea = notesElement.querySelector('textarea');
    const notes = textarea.value;
    
    fetch(`/api/activity/${activityId}/notes`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ notes: notes })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            if (notes && notes.trim()) {
                notesElement.innerHTML = `<p class="mb-0">${notes.replace(/\n/g, '<br>')}</p>`;
            } else {
                notesElement.innerHTML = '<p class="mb-0"></p>';
            }
        } else {
            console.error('Error saving activity notes:', data.error);
            alert('Error saving notes: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error saving activity notes:', error);
        alert('Error saving notes');
    });
}

function cancelActivityNotes(activityId) {
    loadActivityNotes(activityId);
}


</script>
{% endblock %} 